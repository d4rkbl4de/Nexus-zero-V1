<!doctype html>
<!--
EchoVerse — by d4rkblade
License: MIT (see LICENSE)

Attribution request (not required by the MIT License):
If used commercially, please credit "EchoVerse by d4rkblade".

Demo audio:
demo.mp3 © 2025 d4rkblade. All rights reserved.
Not licensed under MIT. Demo/listening only. No reuse/redistribution without permission.
-->
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EchoVerse Ultra+</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Playfair+Display:wght@300;400;500&family=Space+Mono:wght@400;500&display=swap');

    /* CSS Custom Properties - Gradients and Colors */
    :root {
      /* Premium Glassmorphism Palette */
      --glass-bg: rgba(255, 255, 255, 0.03);
      --glass-border: rgba(255, 255, 255, 0.08);
      --glass-blur: blur(20px);

      /* Essential Gradients */
      --gradient-bg-main: linear-gradient(135deg, #000 0%, #0a0a0a 30%, #111 70%, #000 100%);
      --gradient-bg-ui: linear-gradient(135deg, rgba(10, 10, 10, 0.98), rgba(30, 30, 30, 0.1));
      --gradient-btn: linear-gradient(145deg, rgba(255, 255, 255, 0.05), rgba(0, 0, 0, 0.8));
      --gradient-conic: conic-gradient(from 0deg, transparent, rgba(150, 150, 150, 0.2), rgba(200, 200, 200, 0.2), rgba(150, 150, 150, 0.2), transparent);
      --gradient-border: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.2), transparent);
      --gradient-text-title: linear-gradient(to right, #ccc, #fff);
      --gradient-radial-bg: radial-gradient(circle, rgba(150, 150, 150, 0.03), transparent 25%);
      --gradient-radial-ui: radial-gradient(circle at center, rgba(150, 150, 150, 0.05), transparent 70%);
      --gradient-shimmer: linear-gradient(90deg, transparent, rgba(150, 150, 150, 0.1), transparent);
      --gradient-mask-content: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);

      /* Spring Physics */
      --spring-easing: cubic-bezier(0.34, 1.56, 0.64, 1);
      --transition-base: 0.3s var(--spring-easing);

      /* Spacing & Sizing */
      --radius-lg: clamp(16px, 2.5vw, 24px);
      --radius-md: clamp(10px, 1.5vw, 16px);
      --radius-sm: clamp(6px, 1vw, 8px);
      --padding-ui: clamp(12px, 2vw, 24px);

      /* Essential Colors */
      --color-primary: #fff;
      --color-secondary: #888;
      --color-accent: #6366f1;
      --ui-opacity: 1;
      --color-text-base: #888;
      --color-text-hover: #fff;
      --color-border-base: rgba(150, 150, 150, 0.15);
      --color-label: #666;
      --particle-count-limit: 10000;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
      overflow: hidden;
      background: var(--gradient-bg-main);
      font-family: 'Playfair Display', serif;
      position: relative;
      line-height: 1.6;
    }

    body.loading {
      background: linear-gradient(-45deg, #000, #111, #050505, #111);
      background-size: 400% 400%;
      animation: loadingGradient 5s ease infinite;
    }

    @keyframes loadingGradient {
      0% {
        background-position: 0% 50%;
      }

      50% {
        background-position: 100% 50%;
      }

      100% {
        background-position: 0% 50%;
      }
    }

    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--gradient-radial-bg);
      animation: bgFloat 20s ease-in-out infinite;
      z-index: -1;
    }

    body::after {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--gradient-shimmer), url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
      opacity: 0.04;
      animation: bgShimmer 15s linear infinite;
      z-index: -1;
      pointer-events: none;
    }

    /* Consolidated Keyframes */
    @keyframes rotate {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    @keyframes shimmer {
      0% {
        transform: translateX(-100%);
      }

      100% {
        transform: translateX(100%);
      }
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.3;
      }
    }

    @keyframes bgFloat {

      0%,
      100% {
        transform: translate(0, 0);
      }

      25% {
        transform: translate(-10px, 15px);
      }

      50% {
        transform: translate(15px, -10px);
      }

      75% {
        transform: translate(10px, 20px);
      }
    }

    @keyframes modalAppear {
      from {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.8);
      }

      to {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
      }
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    @keyframes titleGlow {
      0% {
        text-shadow: 0 0 25px rgba(200, 200, 200, 0.3), 0 0 40px rgba(150, 150, 150, 0.2);
      }

      100% {
        text-shadow: 0 0 35px rgba(200, 200, 200, 0.5), 0 0 50px rgba(150, 150, 150, 0.3);
      }
    }

    @keyframes subtitlePulse {

      0%,
      100% {
        opacity: 0.7;
      }

      50% {
        opacity: 0.9;
        text-shadow: 0 0 20px rgba(150, 150, 150, 0.3);
      }
    }

    #canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      filter: contrast(1.08) saturate(1.15) brightness(1.05);
    }

    #ui {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%) translateY(var(--ui-translate, 0));
      z-index: 100;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: var(--padding-ui);
      gap: 16px;
      width: clamp(300px, 90vw, 1200px);
      background: var(--glass-bg);
      backdrop-filter: var(--glass-blur);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-lg);
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
      opacity: var(--ui-opacity);
      transition: opacity 0.6s cubic-bezier(0.4, 0, 0.2, 1), transform 0.6s var(--spring-easing), visibility 0.6s;
      visibility: visible;
      contain: layout style;
    }

    #ui.autohide {
      --ui-opacity: 0;
      --ui-translate: 40px;
      pointer-events: none;
      visibility: hidden;
    }

    #ui.zen-mode {
      --ui-opacity: 0;
      --ui-translate: 100px;
      pointer-events: none;
      visibility: hidden;
    }

    .tabs {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 12px;
      background: var(--glass-bg);
      padding: 8px;
      border-radius: 40px;
      backdrop-filter: var(--glass-blur);
      border: 1px solid var(--glass-border);
      position: relative;
      margin-bottom: 24px;
      transition: var(--transition-base);
    }

    /* Shared tab base styles */
    .tab {
      border: none;
      background: rgba(255, 255, 255, 0.05);
      color: rgba(255, 255, 255, 0.5);
      font-family: 'Space Mono', monospace;
      font-weight: 500;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      cursor: pointer;
      border-radius: 20px;
      padding: 8px 16px;
      font-size: 10px;
      transition: all 0.3s var(--spring-easing);
      border: 1px solid transparent;

      &:hover {
        color: #fff;
        background: rgba(255, 255, 255, 0.1);
        transform: translateY(-2px);
      }

      &.active {
        background: #fff;
        color: #000;
        box-shadow: 0 4px 20px rgba(255, 255, 255, 0.3);
        transform: translateY(-2px);
      }
    }



    .settings-container {
      position: relative;
      width: 100%;
      max-width: 90vw;
      scrollbar-width: thin;
      scrollbar-color: rgba(150, 150, 150, 0.5) rgba(0, 0, 0, 0.2);

      &::-webkit-scrollbar {
        width: 6px;
      }

      &::-webkit-scrollbar-track {
        background: rgba(0, 0, 0, 0.2);
        border-radius: 3px;
      }

      &::-webkit-scrollbar-thumb {
        background: rgba(150, 150, 150, 0.5);
        border-radius: 3px;

        &:hover {
          background: rgba(150, 150, 150, 0.8);
        }
      }
    }

    .settings-panel {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
      gap: 16px;
      padding: 24px;
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-md);
      backdrop-filter: var(--glass-blur);
      width: 100%;
      opacity: 0;
      visibility: hidden;
      transform: translateY(20px);
      transition: opacity 0.4s var(--spring-easing), transform 0.4s var(--spring-easing), visibility 0.4s;
      position: absolute;
      top: 0;
      left: 0;
      contain: layout style paint;

      &.active {
        opacity: 1;
        visibility: visible;
        transform: translateY(0);
        position: relative;
      }
    }

    .setting {
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: center;
      padding: 12px;
      border-radius: var(--radius-md);
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid var(--glass-border);
      transition: all 0.3s var(--spring-easing);
      position: relative;

      &:hover {
        background: rgba(255, 255, 255, 0.05);
        transform: scale(1.05);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      }
    }

    .setting-label {
      font-family: 'Space Mono', monospace;
      font-size: clamp(0.6rem, 1vw, 0.69rem);
      font-weight: 500;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: rgba(255, 255, 255, 0.5);
      text-align: center;
      margin-bottom: clamp(6px, 1vw, 10px);
      transition: all 0.4s ease;
      text-shadow: 0 0 12px rgba(255, 255, 255, 0.15);
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: clamp(4px, 0.8vw, 6px);
      word-wrap: break-word;
      inline-size: 100%;
    }

    .setting-label-icon {
      width: clamp(16px, 2.5vw, 24px);
      height: clamp(16px, 2.5vw, 24px);
      margin-bottom: clamp(4px, 0.8vw, 6px);
      opacity: 0.5;
      transition: all 0.4s ease;
      filter: drop-shadow(0 0 8px rgba(150, 150, 150, 0.3));
    }

    .setting:hover .setting-label-icon {
      opacity: 1;
      transform: scale(1.15) rotate(5deg);
      filter: drop-shadow(0 0 15px rgba(150, 150, 150, 0.6));
    }

    .setting:hover .setting-label {
      color: rgba(255, 255, 255, 0.9);
      text-shadow: 0 0 20px rgba(150, 150, 150, 0.4);
      transform: translateY(-4px);
    }

    .setting-label::after {
      content: '';
      position: absolute;
      bottom: -8px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 2px;
      background: var(--gradient-border);
      transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      border-radius: 1px;
    }

    .setting:hover .setting-label::after {
      width: 50px;
    }

    .controls {
      display: flex;
      gap: clamp(8px, 1.5vw, 12px);
      align-items: center;
    }

    .btn {
      width: clamp(40px, 5vw, 52px);
      height: clamp(40px, 5vw, 52px);
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(0, 0, 0, 0.7);
      color: rgba(255, 255, 255, 0.8);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      backdrop-filter: blur(12px);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
      position: relative;
      overflow: hidden;
    }

    .btn::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: var(--gradient-conic);
      animation: rotate 6s linear infinite;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .btn::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      padding: 1px;
      background: var(--gradient-border);
      -webkit-mask: var(--gradient-mask-content);
      mask: var(--gradient-mask-content);
      -webkit-mask-composite: xor;
      mask-composite: exclude;
      pointer-events: none;
      opacity: 0.4;
    }

    .btn:hover::before {
      opacity: 1;
    }

    .btn:hover {
      background: #000000;
      border-color: #ffffff;
      color: #ffffff;
      transform: scale(1.18) translateY(-6px);
      box-shadow: 0 15px 35px rgba(0, 0, 0, 0.7), 0 0 30px rgba(255, 255, 255, 0.4), 0 0 20px rgba(150, 150, 150, 0.15);
    }

    .btn:hover::after {
      opacity: 0.7;
    }

    .btn:active {
      transform: scale(0.92) translateY(2px);
      transition: all 0.15s ease;
    }

    .btn svg {
      width: 20px;
      height: 20px;
      stroke: currentColor;
      stroke-width: 1.8;
      fill: none;
    }

    /* Button Modifiers */
    .btn--primary {
      width: clamp(50px, 6.5vw, 68px);
      height: clamp(50px, 6.5vw, 68px);
      border: 2px solid #ffffff;
      background: #111111;
      box-shadow: 0 12px 35px rgba(0, 0, 0, 0.7), inset 0 1px 0 rgba(255, 255, 255, 0.25), 0 0 0 5px rgba(255, 255, 255, 0.1);
    }

    .btn--primary::after {
      background: var(--gradient-border);
      opacity: 0.8;
    }

    .btn--primary:hover {
      border-color: rgba(150, 150, 150, 0.9);
      background: var(--gradient-btn);
      filter: brightness(1.2);
      box-shadow: 0 18px 45px rgba(0, 0, 0, 0.8), 0 0 45px rgba(150, 150, 150, 0.6), inset 0 1px 0 rgba(255, 255, 255, 0.35);
    }

    .btn--primary svg {
      width: 26px;
      height: 26px;
    }

    .btn--small {
      width: 32px;
      height: 28px;
      font-size: 10px;
      padding: 0;
      border-radius: 4px;
    }


    .file-input {
      position: absolute;
      opacity: 0;
      width: 52px;
      height: 52px;
      cursor: pointer;
    }

    input[type="range"] {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      width: clamp(70px, 10vw, 90px);
      height: 4px;
      background: #000000;
      border-radius: 4px;
      cursor: pointer;
      outline: none;
      transition: all 0.3s ease;
      box-shadow: inset 0 0 4px rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(150, 150, 150, 0.2);
    }

    input[type="range"]::-webkit-slider-track {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      height: 4px;
      border-radius: 4px;
      background: linear-gradient(90deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.25));
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: linear-gradient(135deg, rgba(170, 170, 170, 1), rgba(180, 140, 255, 0.9));
      border: 3px solid rgba(255, 255, 255, 0.3);
      transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5), 0 0 15px rgba(150, 150, 150, 0.4);
      cursor: pointer;
      position: relative;
    }

    input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.4);
      background: linear-gradient(135deg, rgba(190, 190, 190, 1), rgba(200, 160, 255, 1));
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.6), 0 0 25px rgba(150, 150, 150, 0.6);
    }

    input[type="range"]::-moz-range-thumb {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: linear-gradient(135deg, rgba(170, 170, 170, 1), rgba(180, 140, 255, 0.9));
      border: 3px solid rgba(255, 255, 255, 0.3);
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5), 0 0 15px rgba(150, 150, 150, 0.4);
    }

    input[type="range"]::-moz-range-track {
      background: linear-gradient(90deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.25));
      height: 4px;
      border-radius: 4px;
    }

    select {
      background: linear-gradient(145deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.03));
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: clamp(6px, 1vw, 10px);
      padding: clamp(7px, 1vw, 10px) clamp(9px, 1.5vw, 14px);
      color: rgba(255, 255, 255, 0.9);
      font-family: 'Playfair Display', serif;
      font-size: clamp(0.7rem, 1.2vw, 0.81rem);
      cursor: pointer;
      outline: none;
      transition: all 0.4s ease;
      backdrop-filter: blur(20px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.08);
      position: relative;
      overflow: hidden;
    }

    select::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(150, 150, 150, 0.1), transparent);
      opacity: 0;
      transition: opacity 0.4s ease;
    }

    select:hover {
      border-color: rgba(255, 255, 255, 0.08);
      background: linear-gradient(145deg, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0.06));
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.12),
        0 0 20px rgba(150, 150, 150, 0.15);
      transform: translateY(-3px);
    }

    select:hover::before {
      opacity: 1;
    }

    select:focus {
      border-color: rgba(150, 150, 150, 0.6);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.15),
        0 0 25px rgba(150, 150, 150, 0.3);
    }

    select option {
      background: #0a0a0c;
      color: #fff;
    }

    .toggle {
      width: clamp(36px, 5vw, 46px);
      height: clamp(20px, 2.5vw, 26px);
      background: linear-gradient(145deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.03));
      border-radius: clamp(10px, 1.5vw, 13px);
      cursor: pointer;
      position: relative;
      transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      border: 1px solid rgba(255, 255, 255, 0.12);
      box-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.3), 0 3px 10px rgba(0, 0, 0, 0.3);
      position: relative;
      overflow: hidden;
    }

    .toggle::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(150, 150, 150, 0.1), transparent);
      opacity: 0;
      transition: opacity 0.4s ease;
    }

    .toggle.active {
      background: #ffffff;
      border-color: #ffffff;
      box-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.1), 0 3px 15px rgba(255, 255, 255, 0.3);
    }

    .toggle.active::before {
      opacity: 1;
    }

    .toggle::after {
      content: '';
      position: absolute;
      width: 22px;
      height: 22px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(255, 255, 255, 0.9));
      border-radius: 50%;
      top: 1px;
      left: 1px;
      transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.4);
      z-index: 2;
    }

    .toggle.active::after {
      transform: translateX(22px);
      background: linear-gradient(135deg, rgba(255, 255, 255, 1), rgba(240, 240, 255, 0.98));
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5), 0 0 18px rgba(150, 150, 150, 0.4);
    }

    .toggle:hover::after {
      transform: translateX(2px);
    }

    .toggle.active:hover::after {
      transform: translateX(20px);
    }









    .status-item:not(#bpm-display) {
      font-size: 11px;
      color: rgba(255, 255, 255, 0.4);
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      opacity: 0;
      max-width: 0;
      overflow: hidden;
      white-space: nowrap;
      transform: translateY(-5px);
      background: transparent;
      border: none;
      padding: 0;
      margin: 0;
    }

    #status:hover .status-item,
    #status.playing .status-item,
    .status-item.active {
      opacity: 1;
      max-width: 200px;
      transform: translateY(0);
    }

    .status-item:not(#bpm-display)::before {
      content: '|';
      margin-right: 20px;
      opacity: 0.2;
      color: #fff;
    }

    #status.active-beat {
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
      border-bottom-color: rgba(255, 255, 255, 0.3);
    }

    /* Remove separator for the first visible item that isn't BPM if needed,
       but here BPM is always first. */

    .status-item:hover {
      color: #fff;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
    }

    #rec-indicator {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 12px;
      height: 12px;
      opacity: 0;
      transition: all 0.4s ease;
      position: relative;
    }

    #rec-indicator.active {
      opacity: 1;
    }

    #rec-indicator::before {
      content: '';
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #ff4444;
      animation: pulse 1.2s ease-in-out infinite;
      box-shadow: 0 0 10px #ff4444;
    }

    /* Utilities */
    .hidden {
      display: none !important;
    }

    .hint {
      font-family: 'Space Mono', monospace;
      font-size: clamp(0.55rem, 0.9vw, 0.63rem);
      font-weight: 400;
      letter-spacing: 0.2em;
      color: rgba(255, 255, 255, 0.25);
      text-align: center;
      padding: clamp(6px, 1vw, 10px) clamp(15px, 2.5vw, 24px);
      background: rgba(0, 0, 0, 0.4);
      border-radius: clamp(15px, 2.5vw, 24px);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.08);
      transition: all 0.4s ease;
      position: relative;
      overflow: hidden;
    }

    .hint::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: var(--gradient-shimmer);
      transition: 0.5s;
    }

    .hint:hover {
      color: rgba(255, 255, 255, 0.4);
      background: rgba(0, 0, 0, 0.5);
      border-color: rgba(255, 255, 255, 0.15);
    }

    .hint:hover::before {
      left: 100%;
    }

    #preset-modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(10, 10, 20, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: clamp(18px, 3vw, 28px);
      padding: clamp(25px, 4vw, 40px);
      z-index: 200;
      display: none;
      backdrop-filter: blur(16px);
      min-width: clamp(300px, 50vw, 400px);
      max-width: 90vw;
      box-shadow: 0 30px 100px rgba(0, 0, 0, 0.8);
      animation: modalAppear 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
      position: relative;
      overflow: hidden;
    }

    #preset-modal::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 28px;
      padding: 1px;
      background: var(--gradient-border);
      -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor;
      mask-composite: exclude;
      pointer-events: none;
    }



    /* Additional enhanced styles */

    /* Status item styling */
    .status-item {
      font-size: 10px;
      color: rgba(255, 255, 255, 0.4);
      margin: 2px 0;
      padding: 3px 8px;
      border-radius: 4px;
      background: rgba(0, 0, 0, 0.3);
      transition: all 0.3s ease;
    }

    .status-item:hover {
      color: rgba(255, 255, 255, 0.8);
      background: rgba(150, 150, 150, 0.2);
      transform: scale(1.05);
    }

    /* Control footer styling */
    .control-footer {
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 12px 0;
      width: 100%;
      max-width: 300px;
      margin: 0 auto;
    }

    .time-display {
      display: flex;
      justify-content: space-between;
      font-family: 'Space Mono', monospace;
      font-size: 10px;
      color: rgba(255, 255, 255, 0.6);
    }

    /* Footer hint styling */
    .footer-hint {
      margin-top: 10px;
    }

    /* Settings panel scroll enhancement */
    .settings-container {
      scrollbar-width: thin;
      scrollbar-color: rgba(150, 150, 150, 0.5) rgba(0, 0, 0, 0.2);
    }

    .settings-container::-webkit-scrollbar {
      width: 6px;
    }

    .settings-container::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 3px;
    }

    .settings-container::-webkit-scrollbar-thumb {
      background: rgba(150, 150, 150, 0.5);
      border-radius: 3px;
    }

    .settings-container::-webkit-scrollbar-thumb:hover {
      background: rgba(150, 150, 150, 0.8);
    }

    /* Modern title styling */
    .title-text {
      font-family: 'Playfair Display', serif;
      font-size: 3.2rem;
      font-weight: 500;
      background: var(--gradient-text-title);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-align: center;
      margin-bottom: 15px;
      text-shadow: 0 0 30px rgba(255, 255, 255, 0.4);
      letter-spacing: -0.02em;
      position: relative;
      animation: titleGlow 3s ease-in-out infinite alternate;
    }



    .subtitle-text {
      font-family: 'Space Mono', monospace;
      font-size: 1.1rem;
      font-weight: 500;
      color: #888888;
      text-align: center;
      margin-bottom: 25px;
      letter-spacing: 4px;
      text-transform: uppercase;
      position: relative;
      text-shadow: 0 0 40px rgba(255, 255, 255, 0.15);
      animation: subtitlePulse 4s ease-in-out infinite;
    }

    /* Responsive Overrides */
    @media (max-width: 768px) {
      .setting {
        min-width: clamp(70px, 15vw, 100px);
        padding: clamp(8px, 1.2vw, 12px);
      }

      .settings-panel.active {
        grid-template-columns: repeat(2, 1fr);
        gap: 12px;
        padding: 20px 15px;
      }

      .tab {
        padding: 6px 10px;
        font-size: 0.6rem;
      }

      #status:not(:hover) .status-item:not(#bpm-display):not(#rec-indicator) {
        display: none;
      }

      #status:not(:hover) .status-item:not(#bpm-display)::before {
        display: none;
      }

      #status:hover {
        gap: 15px;
        height: 35px;
        opacity: 1;
        background: rgba(0, 0, 0, 0.4);
        backdrop-filter: blur(15px);
      }

      #status:hover .status-item:not(#bpm-display) {
        display: flex;
        max-width: none;
        opacity: 1;
        transform: none;
      }

      .title-text {
        font-size: 2.2rem;
      }

      .subtitle-text {
        font-size: 0.9rem;
        letter-spacing: 2px;
      }

      .btn {
        width: clamp(36px, 8vw, 44px);
        height: clamp(36px, 8vw, 44px);
      }

      .btn--primary {
        width: clamp(44px, 9vw, 56px);
        height: clamp(44px, 9vw, 56px);
      }

      .controls {
        gap: clamp(6px, 1.5vw, 10px);
      }

      .settings-container {
        max-width: 95vw;
      }

    }

    @media (max-width: 480px) {
      .tab {
        min-width: 50px;
        padding: 6px 8px;
        font-size: 0.45rem;
        border-radius: 15px;
      }

      .setting {
        min-width: 60px;
        padding: 6px;
        gap: 4px;
      }

      .setting-label {
        font-size: 0.45rem;
        margin-bottom: 3px;
        gap: 2px;
      }

      .btn {
        width: 36px;
        height: 36px;
      }

      .btn--primary {
        width: 42px;
        height: 42px;
      }

      .title-text {
        font-size: clamp(1.2rem, 6vw, 1.5rem);
      }

      .subtitle-text {
        font-size: clamp(0.45rem, 1.1vw, 0.55rem);
      }
    }

    /* UI Components - Migrated from Inline */
    .spectrum-overlay {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 60px;
      pointer-events: none;
      opacity: 0.6;
      z-index: 9;
      filter: blur(1px);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .modal-preset {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(10, 10, 20, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: clamp(18px, 3vw, 28px);
      padding: clamp(25px, 4vw, 40px);
      z-index: 200;
      display: none;
      backdrop-filter: blur(16px);
      min-width: clamp(300px, 50vw, 400px);
      max-width: 90vw;
      box-shadow: 0 30px 100px rgba(0, 0, 0, 0.8);
      animation: modalAppear 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
      overflow: hidden;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);

      &::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        border-radius: 28px;
        padding: 1px;
        background: var(--gradient-border);
        -webkit-mask: var(--gradient-mask-content);
        mask: var(--gradient-mask-content);
        -webkit-mask-composite: xor;
        mask-composite: exclude;
        pointer-events: none;
      }
    }

    .modal-preset h3 {
      color: rgba(255, 255, 255, 0.9);
      font-weight: 300;
      margin-bottom: 22px;
      letter-spacing: 0.18em;
      font-size: 16px;
      text-align: center;
      text-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
    }

    .modal-preset__input {
      width: 100%;
      padding: 14px;
      background: linear-gradient(145deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.03));
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 12px;
      color: #fff;
      margin-bottom: 18px;
      font-family: 'Playfair Display', serif;
      font-size: 14px;
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.05);
    }

    .modal-preset__list {
      max-height: 240px;
      overflow-y: auto;
      margin-bottom: 18px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 12px;
      padding: 10px;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }

    /* Tooltip System */
    [data-tooltip] {
      position: relative;
    }

    [data-tooltip]::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 120%;
      left: 50%;
      transform: translateX(-50%) translateY(10px);
      background: rgba(0, 0, 0, 0.9);
      color: #fff;
      padding: 6px 12px;
      border-radius: var(--radius-sm);
      font-size: 10px;
      font-family: 'Space Mono', monospace;
      white-space: nowrap;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s var(--spring-easing);
      z-index: 1000;
      border: 1px solid var(--glass-border);
      pointer-events: none;
    }

    [data-tooltip]:hover::after {
      opacity: 1;
      visibility: visible;
      transform: translateX(-50%) translateY(0);
    }

    /* Keyboard Shortcut Badges */
    .btn[data-shortcut]::after {
      content: attr(data-shortcut);
      position: absolute;
      top: -5px;
      right: -5px;
      background: rgba(255, 255, 255, 0.1);
      color: rgba(255, 255, 255, 0.6);
      padding: 2px 4px;
      border-radius: 4px;
      font-size: 8px;
      font-family: 'Space Mono', monospace;
      border: 1px solid var(--glass-border);
      backdrop-filter: blur(4px);
    }

    /* File Drop Zone Visuals */
    .drop-zone {
      position: relative;
    }

    .drop-zone.active {
      outline: 2px dashed var(--color-accent);
      outline-offset: 4px;
      animation: dropZonePulse 1.5s infinite;
    }

    @keyframes dropZonePulse {
      0% {
        outline-color: rgba(99, 102, 241, 0.5);
      }

      50% {
        outline-color: rgba(99, 102, 241, 1);
      }

      100% {
        outline-color: rgba(99, 102, 241, 0.5);
      }
    }

    /* Visual Preset Browser */
    .preset-card {
      position: relative;
      border-radius: var(--radius-md);
      overflow: hidden;
      aspect-ratio: 16/9;
      background: #111;
      cursor: pointer;
      transition: transform 0.3s var(--spring-easing);
      border: 1px solid var(--glass-border);
    }

    .preset-card img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      opacity: 0.7;
      transition: opacity 0.3s ease;
    }

    .preset-card:hover {
      transform: scale(1.05);
    }

    .preset-card:hover img {
      opacity: 1;
    }

    .preset-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 12px;
      padding: 8px;
    }

    /* Zen Mode Progress Bar */
    #zen-progress {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 0%;
      height: 2px;
      background: var(--color-accent);
      z-index: 2000;
      transition: width 0.1s linear;
      display: none;
    }

    body.zen-active #zen-progress {
      display: block;
    }

    body.zen-active #ui,
    body.zen-active .status-bar,
    body.zen-active #spectrum-overlay {
      opacity: 0 !important;
      visibility: hidden !important;
      pointer-events: none !important;
    }

    /* File upload visual feedback helper */
    body.drop-zone-active::after {
      content: 'DROP AUDIO FILE HERE';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(99, 102, 241, 0.2);
      border: 4px dashed var(--color-accent);
      z-index: 3000;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: 'Space Mono', monospace;
      font-size: 24px;
      color: #fff;
      backdrop-filter: blur(10px);
    }

    .preset-card__label {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 8px;
      background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
      font-size: 10px;
      color: #fff;
    }

    .analysis-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 5;
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      padding-bottom: 200px;
      opacity: 0.8;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .spectrogram-container {
      width: 100%;
      height: 120px;
      margin-bottom: 10px;
      display: none;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .dynamics-panel {
      display: none;
      padding: 20px;
      gap: 20px;
      background: rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(10px);
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .meter-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-bottom: 10px;
      font-family: monospace;
      font-size: 11px;
      color: #888;
    }

    .stream-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 90;
      display: none;
      font-family: 'Space Mono', monospace;
      color: #fff;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .stream-header {
      position: absolute;
      top: 40px;
      left: 40px;
      display: flex;
      align-items: center;
      gap: 20px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }


    .stream-header__indicator {
      width: 12px;
      height: 12px;
      background: #ff3333;
      border-radius: 50%;
      animation: pulse 1s infinite;
    }

    .stream-header__title {
      font-size: 24px;
      letter-spacing: 4px;
      font-weight: 700;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
    }

    .stream-footer {
      position: absolute;
      bottom: 40px;
      left: 40px;
      display: flex;
      gap: 30px;
      font-size: 14px;
      background: rgba(0, 0, 0, 0.5);
      padding: 15px 25px;
      border-radius: 12px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }


    .webcam-container {
      position: absolute;
      width: 320px;
      height: 180px;
      background: #000;
      border-radius: 12px;
      overflow: hidden;
      border: 2px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      display: none;
    }


    .webcam-video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }


    .webcam-chroma-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      mix-blend-mode: screen;
      pointer-events: none;
      display: none;
      background: linear-gradient(45deg, rgba(0, 255, 0, 0.2), transparent);
    }

    .status-bar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 20px;
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: center;
      gap: 0px;
      font-family: 'Space Mono', monospace;
      font-size: 11px;
      font-weight: 500;
      color: rgba(255, 255, 255, 0.3);
      z-index: 1000;
      background: transparent;
      padding: 0 20px;
      backdrop-filter: blur(2px);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      opacity: 0.15;
      pointer-events: auto;
      border: none;
      box-shadow: none;
      overflow: visible;

      &:hover,
      &.playing {
        height: 35px;
        opacity: 1;
        background: rgba(0, 0, 0, 0.4);
        backdrop-filter: blur(15px);
        border-bottom: 1px solid rgba(150, 150, 150, 0.1);
        color: rgba(255, 255, 255, 0.8);
        gap: 30px;
      }
    }

    .status-bpm {
      font-size: 12px;
      font-family: 'Space Mono', monospace !important;
      font-weight: 600;
      color: rgba(255, 255, 255, 0.6);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      text-shadow: 0 0 10px rgba(150, 150, 150, 0.3);
      opacity: 1;
      transform: translateY(0);
      position: relative;
    }

    .status-bar:hover .status-bpm,
    .status-bar.playing .status-bpm {
      color: #fff;
      text-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
      transform: scale(1.05);
    }

    /* Dynamic Meter Styles */
    .analyzer-meter {
      width: 30px;
      height: 100%;
      background: #111;
      position: relative;
      border-radius: 4px;
      overflow: hidden;
      flex: 1;
      border: 1px solid #222;
      box-shadow: inset 0 0 10px #000;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .analyzer-track {
      flex: 1;
      height: 6px;
      background: #111;
      border-radius: 3px;
      overflow: hidden;
      box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.5);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .analyzer-wave-canvas {
      width: 100%;
      height: 100px;
      margin-top: 10px;
      border-radius: 8px;
      background: rgba(0, 0, 0, 0.2);
    }

    .histogram-container {
      width: 100%;
      height: 120px;
      margin-top: 10px;
      border-radius: 8px;
      background: rgba(0, 0, 0, 0.3);
      display: block;
    }

    .curve-editor {
      width: 100%;
      height: 100px;
      margin-top: 5px;
      border-radius: 4px;
      background: rgba(0, 0, 0, 0.2);
      cursor: crosshair;
      display: block;
    }

    .curve-controls {
      display: flex;
      gap: 5px;
      margin-top: 5px;
      align-items: center;
    }

    .curve-controls input[type="range"] {
      flex: 1;
    }

    .gr-bar {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 0%;
      background: linear-gradient(to bottom, #ff3333, #aa0000);
      transition: height 0.08s;
      border-bottom: 2px solid #fff;
    }

    .analyzer-row {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 12px;
      font-family: "Space Mono", monospace;
      font-size: 11px;
      color: #aaa;
      background: rgba(255, 255, 255, 0.03);
      padding: 4px 10px;
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.05);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .analyzer-label {
      width: 60px;
    }

    .analyzer-conf-bar {
      height: 100%;
      width: 0%;
      background: #fff;
      transition: width 0.1s, box-shadow 0.1s;
    }

    .analyzer-meters-container {
      display: flex;
      gap: 4px;
      height: 100px;
      align-items: flex-end;
    }

    .analyzer-confidence-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .btn--preset-save {
      background: rgba(150, 150, 150, 0.2) !important;
      border: 1px solid rgba(150, 150, 150, 0.3) !important;
    }

    .setting-color {
      width: 40px;
      height: 30px;
      border: none;
      background: none;
      cursor: pointer;
    }

    .btn--helper {
      width: auto !important;
      padding: 6px 12px !important;
      border-radius: 6px !important;
      font-size: 10px !important;
      height: auto !important;
    }

    .cam-path-btn {
      font-size: 9px !important;
      padding: 6px 10px !important;
      width: auto !important;
      height: auto !important;
      border-radius: 6px !important;
    }

    .cam-path-status {
      font-size: 9px;
      color: rgba(255, 255, 255, 0.5);
      margin-left: 8px;
    }
  </style>

  <script type="importmap">
    { "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
    } }
  </script>
</head>

<body class="loading">
  <div id="zen-progress"></div>
  <canvas id="spectrum-overlay" class="spectrum-overlay"></canvas>

  <div id="preset-modal" class="modal-preset">
    <h3>PRESETS</h3>
    <input type="text" id="preset-name" placeholder="Preset name..." class="modal-preset__input" />
    <div id="preset-list" class="modal-preset__list"></div>
    <div style="display:flex;gap:12px;justify-content:center;">
      <button class="btn btn--small btn--preset-save" id="savePresetBtn">Save</button>
      <button class="btn btn--small" id="closePresetModalBtn">Close</button>
    </div>
  </div>

  <div id="status" class="status-bar">
    <div id="bpm-display" class="status-item status-bpm">-- BPM</div>
    <div id="energy-display" class="status-item">Energy: --</div>
    <div id="note-display" class="status-item">Note: --</div>
    <div id="bar-display" class="status-item">Bar: --</div>
    <div id="rec-indicator" class="status-item"><span id="rec-indicator-text">REC</span></div>
  </div>


  <div id="analysis-overlay" class="analysis-overlay">
    <canvas id="spectrogram-canvas" class="spectrogram-container"></canvas>
    <div id="dynamics-visualization" class="dynamics-panel">
      <div id="gain-reduction-meters" class="analyzer-meters-container"></div>
      <div id="beat-confidence" class="analyzer-confidence-container"></div>
    </div>
  </div>

  <div id="stream-overlay" class="stream-overlay">
    <div id="overlay-top" class="stream-header">
      <div class="stream-header__indicator"></div>
      <div id="overlay-title" class="stream-header__title">ECHOVERSE LIVE</div>
    </div>
    <div id="overlay-bottom" class="stream-footer">
      <div id="overlay-bpm">-- BPM</div>
      <div id="overlay-energy">ENERGY: --</div>
    </div>
    <div id="webcam-container" class="webcam-container">
      <video id="webcam-video" autoplay playsinline class="webcam-video"></video>
      <div id="webcam-chroma-overlay" class="webcam-chroma-overlay"></div>
    </div>
  </div>

  <div id="ui">
    <div class="ui-header">
      <h1 class="title-text">ECHOVERSE</h1>
      <p class="subtitle-text">AUDIO REACTIVE VISUALIZATION</p>
    </div>

    <div class="tabs">
      <button class="tab active" data-tab="main">Main</button>
      <button class="tab" data-tab="color">Color</button>
      <button class="tab" data-tab="camera">Camera</button>
      <button class="tab" data-tab="physics">Physics</button>
      <button class="tab" data-tab="dynamics">Dynamics</button>
      <button class="tab" data-tab="layers">Layers</button>
      <button class="tab" data-tab="fx">FX</button>
      <button class="tab" data-tab="env">Environment</button>
      <button class="tab" data-tab="lighting">Lighting</button>
      <button class="tab" data-tab="grade">Grade</button>
      <button class="tab" data-tab="analysis">Analysis</button>
      <button class="tab" data-tab="share">Share</button>
      <button class="tab" data-tab="extra">Extra</button>
    </div>

    <div class="settings-container">
      <!-- MAIN -->
      <div class="settings-panel active" data-panel="main">
        <div class="setting">
          <span class="setting-label">Form</span>
          <select id="form" data-bind="form">
            <option value="icosahedron">Icosahedron</option>
            <option value="octahedron">Octahedron</option>
            <option value="tetrahedron">Tetrahedron</option>
            <option value="dodecahedron">Dodecahedron</option>
            <option value="torus">Torus</option>
            <option value="torusKnot">Torus Knot</option>
            <option value="sphere">Sphere</option>
            <option value="hyperboloid">Hyperboloid</option>
            <option value="mobius">Möbius Strip</option>
            <option value="kleinBottle">Klein Bottle</option>
            <option value="gyroid">Gyroid Surface</option>
            <option value="cliffordTorus">Clifford Torus</option>
            <option value="hopfFibration">Hopf Fibration</option>
            <option value="seashell">Seashell</option>
            <option value="diniSurface">Dini Surface</option>
          </select>
        </div>
        <div class="setting"><span class="setting-label">Complexity</span><input type="range" id="density"
            data-bind="density" min="1" max="5" step="1" value="3" /></div>
        <div class="setting"><span class="setting-label">Sensitivity</span><input type="range" id="sensitivity"
            data-bind="sensitivity" min="0.2" max="3" step="0.1" value="1.2" /></div>
        <div class="setting"><span class="setting-label">Smoothness</span><input type="range" id="smoothness"
            data-bind="smoothness" min="0" max="1" step="0.05" value="0.7" /></div>
        <div class="setting"><span class="setting-label">Volume</span><input type="range" id="volume" data-bind="volume"
            min="0" max="1" step="0.01" value="0.8" /></div>
        <div class="setting">
          <span class="setting-label">Visual Mode</span>
          <select id="visualMode" data-bind="visualMode">
            <option value="standard">Standard</option>
            <option value="kaleidoscope">Kaleidoscope</option>
          </select>
        </div>
        <div class="setting"><span class="setting-label">Model Spin</span>
          <div class="toggle active" id="toggleModelSpin"></div>
        </div>
        <div class="setting"><span class="setting-label">Spin Speed</span><input type="range" id="modelSpinSpeed"
            data-bind="modelSpinSpeed" min="0" max="2" step="0.01" value="1" /></div>
        <div class="setting">
          <span class="setting-label">Spin Axis</span>
          <select id="modelSpinAxis" data-bind="modelSpinAxis">
            <option value="y">Y Only (Stable)</option>
            <option value="xyz" selected>XYZ (Complex)</option>
          </select>
        </div>
        <div class="setting"><span class="setting-label">Reactive Spin</span>
          <div class="toggle active" id="toggleModelSpinReactive"></div>
        </div>
        <div class="setting"><span class="setting-label">Reactive Amount</span><input type="range"
            id="modelSpinReactivity" data-bind="modelSpinReactivity" min="0" max="1" step="0.01" value="1" /></div>
        <div class="setting"><span class="setting-label">Model Pulse</span>
          <div class="toggle active" id="toggleModelPulse"></div>
        </div>
        <div class="setting"><span class="setting-label">Pulse Amount</span><input type="range" id="modelPulseAmount"
            data-bind="modelPulseAmount" min="0" max="1" step="0.01" value="1" /></div>
      </div>

      <!-- COLOR -->
      <div class="settings-panel" data-panel="color">
        <div class="setting">
          <span class="setting-label">Theme</span>
          <select id="colorTheme" data-bind="colorTheme">
            <option value="void">Void</option>
            <option value="ember">Ember</option>
            <option value="arctic">Arctic</option>
            <option value="neon">Neon</option>
            <option value="sunset">Sunset</option>
            <option value="forest">Forest</option>
            <option value="vapor">Vaporwave</option>
            <option value="gold">Gold</option>
            <option value="blood">Blood</option>
            <option value="ocean">Ocean</option>
            <option value="aurora">Aurora</option>
            <option value="holographic">Holographic</option>
            <option value="plasma">Plasma</option>
            <option value="infrared">Infrared</option>
            <option value="bioluminescent">Bioluminescent</option>
          </select>
        </div>
        <div class="setting"><span class="setting-label">Primary</span><input type="color" id="colorPrimary"
            data-bind="colorPrimary" value="#ffffff" class="setting-color" /></div>
        <div class="setting"><span class="setting-label">Secondary</span><input type="color" id="colorSecondary"
            data-bind="colorSecondary" value="#888888" class="setting-color" /></div>
        <div class="setting"><span class="setting-label">Background</span><input type="color" id="colorBg"
            data-bind="colorBg" value="#000000" class="setting-color" /></div>
        <div class="setting"><span class="setting-label">Reactivity</span><input type="range" id="colorReactivity"
            data-bind="colorReactivity" min="0" max="1" step="0.05" value="0.55" /></div>
        <div class="setting"><span class="setting-label">Hue Rotate</span><input type="range" id="hueRotateSpeed"
            data-bind="hueRotateSpeed" min="0" max="1" step="0.01" value="0" /></div>
        <div class="setting"><span class="setting-label">Bar-Lock</span>
          <div class="toggle active" id="toggleBarLockColors" data-bind="barLockColors"></div>
        </div>
      </div>

      <!-- CAMERA -->
      <div class="settings-panel" data-panel="camera">
        <div class="setting">
          <span class="setting-label">Mode</span>
          <select id="cameraMode" data-bind="cameraMode">
            <option value="orbit">Smooth Orbit</option>
            <option value="reactive">Reactive</option>
            <option value="cinematic">Cinematic</option>
            <option value="spiral">Spiral</option>
            <option value="figure8">Figure 8</option>
            <option value="vortex">Vortex Pull</option>
            <option value="pendulum">Pendulum</option>
            <option value="flythrough">Fly Through</option>
            <option value="drunk">Drunk</option>
            <option value="preset">Preset Playback</option>
          </select>
        </div>
        <div class="setting"><span class="setting-label">Distance</span><input type="range" id="cameraDistance"
            data-bind="cameraDistance" min="15" max="80" step="1" value="35" /></div>
        <div class="setting"><span class="setting-label">Speed</span><input type="range" id="cameraSpeed"
            data-bind="cameraSpeed" min="0.1" max="2" step="0.05" value="0.6" /></div>
        <div class="setting"><span class="setting-label">Shake</span><input type="range" id="cameraShake"
            data-bind="cameraShake" min="0" max="2" step="0.05" value="0.45" /></div>
        <div class="setting"><span class="setting-label">FOV</span><input type="range" id="cameraFov"
            data-bind="cameraFov" min="30" max="120" step="5" value="60" /></div>
        <div class="setting"><span class="setting-label">Beat Zoom</span>
          <div class="toggle active" id="toggleBeatZoom" data-bind="cameraBeatZoom"></div>
        </div>
        <div class="setting"><span class="setting-label">Auto Angles</span>
          <div class="toggle" id="toggleAutoAngles" data-bind="cameraAutoAngles"></div>
        </div>

        <!-- DOF Controls -->
        <div class="setting"><span class="setting-label">Depth of Field</span>
          <div class="toggle" id="toggleDOF" data-bind="dofEnabled"></div>
        </div>
        <div class="setting"><span class="setting-label">Focus Dist</span><input type="range" id="dofFocusDistance"
            data-bind="dofFocusDistance" min="5" max="100" step="1" value="35" /></div>
        <div class="setting"><span class="setting-label">Aperture</span><input type="range" id="dofAperture"
            data-bind="dofAperture" min="0.001" max="0.1" step="0.001" value="0.025" /></div>
        <div class="setting"><span class="setting-label">Bokeh Scale</span><input type="range" id="dofBokehScale"
            data-bind="dofBokehScale" min="0.5" max="5" step="0.1" value="2.5" /></div>
        <div class="setting">
          <span class="setting-label">Auto Focus</span>
          <select id="dofAutoFocus" data-bind="dofAutoFocus">
            <option value="center">Center</option>
            <option value="energy">Follow Energy</option>
            <option value="manual">Manual</option>
          </select>
        </div>

        <!-- Camera Presets (8 Slots) -->
        <div class="setting" style="grid-column: span 2; width: 100%;">
          <span class="setting-label">Camera Presets</span>
          <div style="display: flex; gap: 4px; flex-wrap: wrap; justify-content: center;">
            <button class="btn btn--small cam-preset-btn" data-slot="1">1</button>
            <button class="btn btn--small cam-preset-btn" data-slot="2">2</button>
            <button class="btn btn--small cam-preset-btn" data-slot="3">3</button>
            <button class="btn btn--small cam-preset-btn" data-slot="4">4</button>
            <button class="btn btn--small cam-preset-btn" data-slot="5">5</button>
            <button class="btn btn--small cam-preset-btn" data-slot="6">6</button>
            <button class="btn btn--small cam-preset-btn" data-slot="7">7</button>
            <button class="btn btn--small cam-preset-btn" data-slot="8">8</button>
          </div>
          <div style="display: flex; gap: 6px; margin-top: 8px; justify-content: center;">
            <button class="btn btn--small" id="saveCamPreset">Save</button>
            <button class="btn btn--small" id="clearCamPreset">Clear</button>
          </div>
        </div>
        <div class="setting"><span class="setting-label">Zen Mode</span>
          <div class="toggle" id="toggleZenMode"></div>
        </div>
        <div class="setting"><span class="setting-label">Capture & Share</span>
          <div style="display: flex; gap: 8px;">
            <button class="btn btn--small" id="takeSnapshot">📷</button>
            <button class="btn btn--small" id="exportPreset">📤</button>
            <button class="btn btn--small" id="importPreset">📥</button>
          </div>
        </div>

        <!-- Transition Controls -->
        <div class="setting">
          <span class="setting-label">Transition</span>
          <select id="cameraTransitionType" data-bind="cameraTransitionType">
            <option value="linear">Linear</option>
            <option value="ease" selected>Ease</option>
            <option value="bounce">Bounce</option>
            <option value="elastic">Elastic</option>
          </select>
        </div>
        <div class="setting"><span class="setting-label">Trans. Time</span><input type="range"
            id="cameraTransitionDuration" data-bind="cameraTransitionDuration" min="0.2" max="5" step="0.1"
            value="2.0" /></div>

        <!-- Shake Profiles -->
        <div class="setting">
          <span class="setting-label">Shake Profile</span>
          <select id="shakeProfile" data-bind="shakeProfile">
            <option value="none">None</option>
            <option value="earthquake">Earthquake</option>
            <option value="explosion">Explosion</option>
            <option value="heartbeat">Heartbeat</option>
            <option value="handheld">Handheld</option>
          </select>
        </div>
        <div class="setting">
          <span class="setting-label">Shake Dir</span>
          <select id="shakeDirectionBias" data-bind="shakeDirectionBias">
            <option value="xyz" selected>All (XYZ)</option>
            <option value="xy">XY</option>
            <option value="xz">XZ</option>
            <option value="yz">YZ</option>
            <option value="x">X Only</option>
            <option value="y">Y Only</option>
            <option value="z">Z Only</option>
          </select>
        </div>
        <div class="setting"><span class="setting-label">Shake Freq</span><input type="range" id="shakeFrequency"
            data-bind="shakeFrequency" min="0.1" max="5" step="0.1" value="1.0" /></div>
        <div class="setting"><span class="setting-label">Shake Decay</span><input type="range" id="shakeDecay"
            data-bind="shakeDecay" min="0.8" max="0.99" step="0.01" value="0.95" /></div>

        <!-- Path Recording -->
        <div class="setting" style="grid-column: span 2; width: 100%;">
          <span class="setting-label">Camera Path</span>
          <div style="display: flex; gap: 6px; margin-top: 6px; justify-content: center;">
            <button class="btn cam-path-btn" id="camPathRecord">⏺ Record</button>
            <button class="btn cam-path-btn" id="camPathPlay">▶ Play</button>
            <button class="btn cam-path-btn" id="camPathStop">⏹ Stop</button>
          </div>
          <div style="display: flex; gap: 6px; margin-top: 6px; justify-content: center;">
            <span class="setting-label" style="font-size:9px; margin-bottom:0;">Loop</span>
            <div class="toggle" id="toggleCamPathLoop" data-bind="camPathLoop"></div>
            <span id="camPathStatus" class="cam-path-status">0 keyframes</span>
          </div>
        </div>
      </div>

      <!-- PHYSICS -->
      <div class="settings-panel" data-panel="physics">
        <div class="setting">
          <span class="setting-label">Particle Mode</span>
          <select id="particleMode" data-bind="particleMode">
            <option value="stardust">Stardust (GPU)</option>
            <option value="neon-rain">Neon Rain (GPU)</option>
            <option value="quantum">Quantum (GPU)</option>
            <option value="filament">Filament (GPU)</option>
            <option value="swarm" selected>Legacy Swarm</option>
            <option value="orbital">Legacy Orbital</option>
          </select>
        </div>
        <div class="setting">
          <span class="setting-label">Field</span>
          <select id="fieldMode" data-bind="fieldMode">
            <option value="harmonic" selected>Harmonic</option>
            <option value="noise">Noise</option>
            <option value="curl">Curl Noise</option>
            <option value="spiral">Spiral</option>
          </select>
        </div>
        <div class="setting">
          <span class="setting-label">Symmetry</span>
          <select id="symmetry" data-bind="symmetry">
            <option value="3">3</option>
            <option value="4">4</option>
            <option value="5">5</option>
            <option value="6" selected>6</option>
            <option value="8">8</option>
            <option value="12">12</option>
          </select>
        </div>
        <div class="setting"><span class="setting-label">Turbulence</span><input type="range" id="turbulence"
            data-bind="turbulence" min="0" max="2" step="0.05" value="0.25" /></div>
        <div class="setting"><span class="setting-label">Cohesion</span><input type="range" id="cohesion"
            data-bind="cohesion" min="0" max="1" step="0.05" value="0.55" /></div>
        <div class="setting">
          <span class="setting-label">Count</span>
          <select id="particleCount" data-bind="particleCount">
            <option value="500">500</option>
            <option value="1500" selected>1500</option>
            <option value="4000">4000</option>
            <option value="8000">8000</option>
          </select>
        </div>
      </div>

      <!-- DYNAMICS -->
      <div class="settings-panel" data-panel="dynamics">
        <div class="setting"><span class="setting-label">Physics System</span>
          <div class="toggle active" id="toggleDynParticles" data-bind="dynamicParticlesEnabled"></div>
        </div>
        <div class="setting">
          <span class="setting-label">Emitter</span>
          <select id="dynParticleEmitter" data-bind="dynParticleEmitter">
            <option value="radial">Radial Burst</option>
            <option value="vortex">Vortex Spiral</option>
            <option value="matrix">Matrix Digital Rain</option>
            <option value="sphere" selected>Sphere (Legacy)</option>
            <option value="box">Box (Legacy)</option>
            <option value="ring">Ring (Legacy)</option>
            <option value="mesh">Mesh (Legacy)</option>
          </select>
        </div>
        <div class="setting">
          <span class="setting-label">Velocity</span>
          <select id="dynParticleVelocity" data-bind="dynParticleVelocity">
            <option value="outward" selected>Outward</option>
            <option value="random">Random</option>
            <option value="directional">Directional</option>
          </select>
        </div>
        <div class="setting">
          <span class="setting-label">Shape</span>
          <select id="dynParticleShape" data-bind="dynParticleShape">
            <option value="circle" selected>Circle</option>
            <option value="square">Square</option>
            <option value="tri">Triangle</option>
            <option value="star">Star</option>
            <option value="mesh">3D Mesh</option>
          </select>
        </div>
        <div class="setting"><span class="setting-label">Count</span><input type="range" id="dynParticleCount"
            data-bind="dynParticleCount" min="500" max="8000" step="500" value="2000" /></div>
        <div class="setting"><span class="setting-label">Spawn Rate</span><input type="range" id="dynParticleSpawnRate"
            data-bind="dynParticleSpawnRate" min="1" max="100" step="1" value="20" /></div>
        <div class="setting"><span class="setting-label">Lifespan</span><input type="range" id="dynParticleLifespan"
            data-bind="dynParticleLifespan" min="0.5" max="10" step="0.5" value="3" /></div>
        <div class="setting"><span class="setting-label">Size</span><input type="range" id="dynParticleSize"
            data-bind="dynParticleSize" min="0.05" max="0.5" step="0.01" value="0.15" /></div>
        <div class="setting"><span class="setting-label">Gravity</span><input type="range" id="dynForceGravity"
            data-bind="dynForceGravity" min="-2" max="2" step="0.1" value="0" /></div>
        <div class="setting"><span class="setting-label">Vortex</span><input type="range" id="dynForceVortex"
            data-bind="dynForceVortex" min="0" max="5" step="0.1" value="0" /></div>
        <div class="setting"><span class="setting-label">Turbulence</span><input type="range" id="dynForceTurbulence"
            data-bind="dynForceTurbulence" min="0" max="2" step="0.05" value="0.5" /></div>
        <div class="setting"><span class="setting-label">Attractor</span><input type="range" id="dynAttractorStrength"
            data-bind="dynAttractorStrength" min="0" max="5" step="0.1" value="1" /></div>
        <div class="setting"><span class="setting-label">Collisions</span>
          <div class="toggle" id="toggleDynCollisions" data-bind="dynCollisionEnabled"></div>
        </div>
        <div class="setting"><span class="setting-label">Reactive Spawn</span>
          <div class="toggle active" id="toggleDynAudioSpawn" data-bind="dynAudioReactiveSpawn"></div>
        </div>
        <div class="setting"><span class="setting-label">Reactive Vel</span><input type="range"
            id="dynAudioVelocityMult" data-bind="dynAudioVelocityMult" min="0" max="5" step="0.1" value="1" /></div>
        <div class="setting"><span class="setting-label">Trails</span><input type="range" id="dynParticleTrailLength"
            data-bind="dynParticleTrailLength" min="0" max="20" step="1" value="0" /></div>
      </div>

      <!-- LAYERS -->
      <div class="settings-panel" data-panel="layers">
        <div class="setting"><span class="setting-label">Wireframe Core</span>
          <div class="toggle active" id="toggleWireframe" data-bind="showWireframeCore"></div>
        </div>
        <div class="setting"><span class="setting-label">Rim Glow</span>
          <div class="toggle active" id="toggleRimGlow" data-bind="showRimGlow"></div>
        </div>
        <div class="setting"><span class="setting-label">Inner Shell</span>
          <div class="toggle active" id="toggleInner" data-bind="showInner"></div>
        </div>
        <div class="setting"><span class="setting-label">Outer Shell</span>
          <div class="toggle active" id="toggleOuter" data-bind="showOuter"></div>
        </div>
        <div class="setting"><span class="setting-label">Waveform Ring</span>
          <div class="toggle active" id="toggleWaveform" data-bind="showWaveform"></div>
        </div>
        <div class="setting"><span class="setting-label">Freq Bars</span>
          <div class="toggle" id="toggleBars" data-bind="showBars"></div>
        </div>
        <div class="setting"><span class="setting-label">Connections</span>
          <div class="toggle active" id="toggleConnections" data-bind="showConnections"></div>
        </div>
        <div class="setting"><span class="setting-label">Core Particles</span>
          <div class="toggle active" id="toggleParticles" data-bind="showParticles"></div>
        </div>
        <div class="setting"><span class="setting-label">Deep Field Particles</span>
          <div class="toggle active" id="toggleDeepParticles" data-bind="showDeepParticles"></div>
        </div>
        <div class="setting"><span class="setting-label">Shockwaves</span>
          <div class="toggle active" id="toggleShockwaves" data-bind="showShockwaves"></div>
        </div>
        <div class="setting"><span class="setting-label">Rings</span>
          <div class="toggle active" id="toggleRings" data-bind="showRings"></div>
        </div>
        <div class="setting"><span class="setting-label">Light Rays</span>
          <div class="toggle" id="toggleLightRays" data-bind="showLightRays"></div>
        </div>
        <div class="setting"><span class="setting-label">Aurora</span>
          <div class="toggle" id="toggleAurora" data-bind="showAurora"></div>
        </div>
        <div class="setting"><span class="setting-label">Energy Field</span>
          <div class="toggle" id="toggleEnergyField" data-bind="showEnergyField"></div>
        </div>
        <div class="setting"><span class="setting-label">Orbitals</span>
          <div class="toggle" id="toggleOrbitals" data-bind="showOrbitals"></div>
        </div>

        <div class="group-title">Particle Visibility</div>
        <div class="setting"><span class="setting-label">Particle Size</span><input type="range" id="particleSizeMult"
            data-bind="particleSizeMult" min="0.5" max="2.5" step="0.05" value="1" /></div>
        <div class="setting"><span class="setting-label">Particle Brightness</span><input type="range"
            id="particleBrightness" data-bind="particleBrightness" min="0.3" max="2.0" step="0.05" value="1" /></div>

        <div class="group-title">Shockwave Tuning</div>
        <div class="setting"><span class="setting-label">Shockwave Intensity</span><input type="range"
            id="shockwaveIntensity" data-bind="shockwaveIntensity" min="0" max="1.2" step="0.05" value="0.7" /></div>
        <div class="setting"><span class="setting-label">Impact Sensitivity</span><input type="range"
            id="shockwaveImpactThreshold" data-bind="shockwaveImpactThreshold" min="0" max="1" step="0.02"
            value="0.55" /></div>
        <div class="setting"><span class="setting-label">Min Time Between</span><input type="range"
            id="shockwaveCooldown" data-bind="shockwaveCooldown" min="0.05" max="0.8" step="0.01" value="0.22" /></div>
      </div>

      <!-- FX -->
      <div class="settings-panel" data-panel="fx">
        <div class="setting"><span class="setting-label">Bloom</span><input type="range" id="bloomStrength"
            data-bind="bloomStrength" min="0" max="3" step="0.05" value="0.8" /></div>
        <div class="setting"><span class="setting-label">Glow Radius</span><input type="range" id="bloomRadius"
            data-bind="bloomRadius" min="0" max="2" step="0.05" value="0.7" /></div>
        <div class="setting">
          <span class="setting-label">Trails</span>
          <select id="trailMode" data-bind="trailMode">
            <option value="none">None</option>
            <option value="light">Light</option>
            <option value="medium" selected>Medium</option>
            <option value="heavy">Heavy</option>
            <option value="smear">Smear</option>
          </select>
        </div>
        <div class="setting"><span class="setting-label">Glitch</span><input type="range" id="glitchAmount"
            data-bind="glitchAmount" min="0" max="1" step="0.05" value="0" /></div>
        <div class="setting"><span class="setting-label">Vignette</span><input type="range" id="vignette"
            data-bind="vignette" min="0" max="1" step="0.05" value="0.35" /></div>
        <div class="setting"><span class="setting-label">Grain</span><input type="range" id="grain" data-bind="grain"
            min="0" max="1" step="0.05" value="0.12" /></div>
        <div class="setting"><span class="setting-label">RGB Split</span><input type="range" id="aberration"
            data-bind="aberration" min="0" max="1" step="0.05" value="0.08" /></div>
        <div class="setting"><span class="setting-label">Anamorphic</span><input type="range" id="anamorphic"
            data-bind="anamorphic" min="0" max="1" step="0.05" value="0" /></div>
        <div class="setting"><span class="setting-label">Scanlines</span><input type="range" id="scanlines"
            data-bind="scanlines" min="0" max="1" step="0.05" value="0" /></div>
        <div class="setting">
          <span class="setting-label">Film Look</span>
          <select id="filmLook" data-bind="filmLook">
            <option value="none">None</option>
            <option value="cinematic">Cinematic</option>
            <option value="vintage">Vintage</option>
            <option value="neon">Neon Night</option>
            <option value="dream">Dream</option>
          </select>
        </div>
      </div>

      <!-- ENV -->
      <div class="settings-panel" data-panel="env">
        <div class="setting">
          <span class="setting-label">Scene</span>
          <select id="environment" data-bind="environment">
            <option value="void">Void</option>
            <option value="grid">Grid Floor</option>
            <option value="stars">Starfield</option>
            <option value="nebula">Nebula</option>
            <option value="matrix">Matrix Rain</option>
            <option value="ocean">Deep Ocean</option>
            <option value="crystal">Crystal Cave</option>
          </select>
        </div>
        <div class="setting"><span class="setting-label">Fog</span><input type="range" id="fogDensity"
            data-bind="fogDensity" min="0" max="0.05" step="0.002" value="0.008" /></div>
        <div class="setting"><span class="setting-label">Rings</span><input type="range" id="ringCount"
            data-bind="ringCount" min="0" max="8" step="1" value="3" /></div>
        <div class="setting">
          <span class="setting-label">BG Pattern</span>
          <select id="bgPattern" data-bind="bgPattern">
            <option value="none" selected>None</option>
            <option value="mandala">Mandala</option>
            <option value="lattice">Lattice</option>
            <option value="plasma">Plasma</option>
            <option value="voronoi">Voronoi</option>
            <option value="waves">Sine Waves</option>
          </select>
        </div>
        <div class="setting"><span class="setting-label">Pattern Str</span><input type="range" id="bgPatternStrength"
            data-bind="bgPatternStrength" min="0" max="1" step="0.05" value="0.35" /></div>
      </div>

      <!-- EXTRA -->
      <div class="settings-panel" data-panel="extra">
        <div class="setting"><span class="setting-label">Spectrum</span>
          <div class="toggle active" id="toggleSpectrum" data-bind="showSpectrum"></div>
        </div>
        <div class="setting"><span class="setting-label">Auto-Pilot</span>
          <div class="toggle" id="toggleAutoPilot" data-bind="autoPilot"></div>
        </div>
        <div class="setting"><span class="setting-label">Beat Flash</span>
          <div class="toggle active" id="toggleBeatFlash" data-bind="beatFlash"></div>
        </div>
        <div class="setting"><span class="setting-label">Color Cycle</span>
          <div class="toggle active" id="toggleColorCycle" data-bind="colorCycle"></div>
        </div>
        <div class="setting"><span class="setting-label">Synesthesia</span>
          <div class="toggle" id="toggleSynesthesia" data-bind="synesthesia"></div>
        </div>
        <div class="setting"><span class="setting-label">Harmonic Snap</span>
          <div class="toggle active" id="toggleHarmonicSnap" data-bind="harmonicSnap"></div>
        </div>
        <div class="setting"><span class="setting-label">Negative Space</span>
          <div class="toggle" id="toggleNegativeSpace" data-bind="negativeSpace"></div>
        </div>
        <div class="setting"><span class="setting-label">Reactive BG</span>
          <div class="toggle active" id="toggleReactiveBg" data-bind="reactiveBg"></div>
        </div>
        <div class="setting"><span class="setting-label">Presets</span><button class="btn btn--helper"
            id="openPresetModalBtn">Open</button></div>
      </div>
      <!-- LIGHTING -->
      <div class="settings-panel" data-panel="lighting">
        <div class="group-title">3-Point Studio</div>
        <div class="setting">
          <span class="setting-label">Key Light</span>
          <input type="range" id="lightKeyInt" data-bind="lightKeyInt" min="0" max="5" step="0.1" value="1.5" />
        </div>
        <div class="setting">
          <span class="setting-label">Fill Light</span>
          <input type="range" id="lightFillInt" data-bind="lightFillInt" min="0" max="5" step="0.1" value="0.8" />
        </div>
        <div class="setting">
          <span class="setting-label">Rim Light</span>
          <input type="range" id="lightRimInt" data-bind="lightRimInt" min="0" max="10" step="0.1" value="3.0" />
        </div>

        <div class="group-title">Atmosphere</div>
        <div class="setting">
          <span class="setting-label">God Rays</span>
          <input type="range" id="godRaysInt" data-bind="godRaysInt" min="0" max="1" step="0.05" value="0.4" />
        </div>
        <div class="setting">
          <span class="setting-label">HDRI Studio</span>
          <div class="toggle active" id="toggleHDRI" data-bind="showHDRI"></div>
        </div>
        <div class="setting">
          <span class="setting-label">Gobo Mode</span>
          <select id="goboMode" data-bind="goboMode">
            <option value="none">None</option>
            <option value="bars">Bars</option>
            <option value="rings">Rings</option>
            <option value="cloud">Cloud</option>
          </select>
        </div>

        <div class="group-title">Materials</div>
        <div class="setting">
          <span class="setting-label">Rendering</span>
          <select id="renderStyle" data-bind="renderStyle">
            <option value="wire">Wireframe</option>
            <option value="solid">Standard Solid</option>
            <option value="physic">PBR Cinematic</option>
          </select>
        </div>
        <div class="setting">
          <span class="setting-label">Metalness</span>
          <input type="range" id="matMetal" data-bind="matMetal" min="0" max="1" step="0.01" value="0.9" />
        </div>
        <div class="setting">
          <span class="setting-label">Roughness</span>
          <input type="range" id="matRough" data-bind="matRough" min="0" max="1" step="0.01" value="0.1" />
        </div>
      </div>

      <!-- COLOR GRADE -->
      <div class="settings-panel" data-panel="grade">
        <!-- Histogram Visualization -->
        <div class="group-title">Histogram (RGB Parade)</div>
        <canvas id="histogram-canvas" class="histogram-container"></canvas>

        <!-- Film Response Curves -->
        <div class="group-title">Film Response</div>
        <div class="setting">
          <span class="setting-label">Film Curve</span>
          <select id="filmCurve" data-bind="filmCurve">
            <option value="0">None</option>
            <option value="1">Kodak Vision3 500T</option>
            <option value="2">Fuji Eterna 8543</option>
          </select>
        </div>

        <!-- RGB Curves -->
        <div class="group-title">RGB Curves</div>
        <div class="setting">
          <span class="setting-label">Red Channel</span>
          <canvas id="curveR-canvas" class="curve-editor" width="200" height="100"></canvas>
          <div class="curve-controls">
            <input type="range" id="curveRShadows" data-bind="curveRShadows" min="0" max="1" step="0.01" value="0.0" />
            <input type="range" id="curveRMids" data-bind="curveRMids" min="0" max="1" step="0.01" value="0.33" />
            <input type="range" id="curveRHighlights" data-bind="curveRHighlights" min="0" max="1" step="0.01" value="0.66" />
            <input type="range" id="curveRWhites" data-bind="curveRWhites" min="0" max="1" step="0.01" value="1.0" />
            <button class="btn" onclick="resetCurve('R')" style="width:auto;padding:3px 8px;font-size:10px;">Reset</button>
          </div>
        </div>
        <div class="setting">
          <span class="setting-label">Green Channel</span>
          <canvas id="curveG-canvas" class="curve-editor" width="200" height="100"></canvas>
          <div class="curve-controls">
            <input type="range" id="curveGShadows" data-bind="curveGShadows" min="0" max="1" step="0.01" value="0.0" />
            <input type="range" id="curveGMids" data-bind="curveGMids" min="0" max="1" step="0.01" value="0.33" />
            <input type="range" id="curveGHighlights" data-bind="curveGHighlights" min="0" max="1" step="0.01" value="0.66" />
            <input type="range" id="curveGWhites" data-bind="curveGWhites" min="0" max="1" step="0.01" value="1.0" />
            <button class="btn" onclick="resetCurve('G')" style="width:auto;padding:3px 8px;font-size:10px;">Reset</button>
          </div>
        </div>
        <div class="setting">
          <span class="setting-label">Blue Channel</span>
          <canvas id="curveB-canvas" class="curve-editor" width="200" height="100"></canvas>
          <div class="curve-controls">
            <input type="range" id="curveBShadows" data-bind="curveBShadows" min="0" max="1" step="0.01" value="0.0" />
            <input type="range" id="curveBMids" data-bind="curveBMids" min="0" max="1" step="0.01" value="0.33" />
            <input type="range" id="curveBHighlights" data-bind="curveBHighlights" min="0" max="1" step="0.01" value="0.66" />
            <input type="range" id="curveBWhites" data-bind="curveBWhites" min="0" max="1" step="0.01" value="1.0" />
            <button class="btn" onclick="resetCurve('B')" style="width:auto;padding:3px 8px;font-size:10px;">Reset</button>
          </div>
        </div>

        <!-- Channel Mixer -->
        <div class="group-title">Channel Mixer</div>
        <div class="setting">
          <span class="setting-label">R from R</span>
          <input type="range" id="channelMixerRR" data-bind="channelMixerRR" min="-2" max="2" step="0.01" value="1.0" />
        </div>
        <div class="setting">
          <span class="setting-label">R from G</span>
          <input type="range" id="channelMixerRG" data-bind="channelMixerRG" min="-2" max="2" step="0.01" value="0.0" />
        </div>
        <div class="setting">
          <span class="setting-label">R from B</span>
          <input type="range" id="channelMixerRB" data-bind="channelMixerRB" min="-2" max="2" step="0.01" value="0.0" />
        </div>
        <div class="setting">
          <span class="setting-label">G from R</span>
          <input type="range" id="channelMixerGR" data-bind="channelMixerGR" min="-2" max="2" step="0.01" value="0.0" />
        </div>
        <div class="setting">
          <span class="setting-label">G from G</span>
          <input type="range" id="channelMixerGG" data-bind="channelMixerGG" min="-2" max="2" step="0.01" value="1.0" />
        </div>
        <div class="setting">
          <span class="setting-label">G from B</span>
          <input type="range" id="channelMixerGB" data-bind="channelMixerGB" min="-2" max="2" step="0.01" value="0.0" />
        </div>
        <div class="setting">
          <span class="setting-label">B from R</span>
          <input type="range" id="channelMixerBR" data-bind="channelMixerBR" min="-2" max="2" step="0.01" value="0.0" />
        </div>
        <div class="setting">
          <span class="setting-label">B from G</span>
          <input type="range" id="channelMixerBG" data-bind="channelMixerBG" min="-2" max="2" step="0.01" value="0.0" />
        </div>
        <div class="setting">
          <span class="setting-label">B from B</span>
          <input type="range" id="channelMixerBB" data-bind="channelMixerBB" min="-2" max="2" step="0.01" value="1.0" />
        </div>

        <!-- Color Temperature -->
        <div class="group-title">Color Temperature</div>
        <div class="setting">
          <span class="setting-label">Temperature (K)</span>
          <input type="range" id="colorTemp" data-bind="colorTemp" min="2000" max="10000" step="100" value="6500" />
        </div>
        <div class="setting">
          <span class="setting-label">Tint (Magenta/Green)</span>
          <input type="range" id="tint" data-bind="tint" min="-1" max="1" step="0.01" value="0.0" />
        </div>

        <!-- Split Toning -->
        <div class="group-title">Split Toning</div>
        <div class="setting">
          <span class="setting-label">Shadow Tint</span>
          <input type="color" id="splitToneShadows" data-bind="splitToneShadows" value="#000000" />
        </div>
        <div class="setting">
          <span class="setting-label">Highlight Tint</span>
          <input type="color" id="splitToneHighlights" data-bind="splitToneHighlights" value="#ffffff" />
        </div>
        <div class="setting">
          <span class="setting-label">Balance</span>
          <input type="range" id="splitToneBalance" data-bind="splitToneBalance" min="-1" max="1" step="0.01" value="0.0" />
        </div>

        <!-- Saturation & Vibrance -->
        <div class="group-title">Saturation & Vibrance</div>
        <div class="setting">
          <span class="setting-label">Sat Boost</span>
          <input type="range" id="gradeSat" data-bind="gradeSat" min="0" max="2" step="0.01" value="1.0" />
        </div>
        <div class="setting">
          <span class="setting-label">Vibrance</span>
          <input type="range" id="gradeVibrance" data-bind="gradeVibrance" min="0" max="2" step="0.01" value="1.2" />
        </div>

        <!-- LUT / Hue Rotate -->
        <div class="group-title">LUT / Hue</div>
        <div class="setting">
          <span class="setting-label">LUT Intensity</span>
          <input type="range" id="lutInt" data-bind="lutInt" min="0" max="1" step="0.01" value="0.5" />
        </div>
        <div class="setting">
          <span class="setting-label">Load LUT (.cube)</span>
          <input type="file" id="lutFile" accept=".cube" style="display:none;" />
          <button class="btn" style="width:auto;height:auto;padding:5px 10px;font-size:10px;"
            onclick="document.getElementById('lutFile').click()">Choose File</button>
        </div>
        <div class="setting">
          <span class="setting-label">Color Wheel</span>
          <input type="range" id="hueRotate" data-bind="hueRotate" min="0" max="360" step="1" value="0" />
        </div>
      </div>

      <!-- ANALYSIS -->
      <div class="settings-panel" data-panel="analysis">
        <div class="group-title">Spectrogram</div>
        <div class="setting">
          <span class="setting-label">Display</span>
          <select id="spectrogramMode" data-bind="spectrogramMode">
            <option value="off">Off</option>
            <option value="horizontal">Horizontal</option>
            <option value="vertical">Vertical</option>
          </select>
        </div>
        <div class="setting">
          <span class="setting-label">FFT Size</span>
          <select id="analyzerFftSize" data-bind="analyzerFftSize">
            <option value="128">128</option>
            <option value="256">256</option>
            <option value="512">512</option>
            <option value="1024" selected>1024</option>
            <option value="2048">2048</option>
          </select>
        </div>
        <div class="setting">
          <span class="setting-label">Color Map</span>
          <select id="spectrogramColor" data-bind="spectrogramColor">
            <option value="grayscale">Grayscale</option>
            <option value="heatmap">Heatmap</option>
            <option value="plasma">Plasma</option>
            <option value="viridis">Viridis</option>
          </select>
        </div>

        <div class="group-title">Dynamics & Beats</div>
        <div id="meter-values" class="meter-grid">
          <div>RMS: <span id="rms-val" style="color:#fff;">0.00</span></div>
          <div>PEAK: <span id="peak-val" style="color:#fff;">0.00</span></div>
        </div>
        <div class="setting">
          <span class="setting-label">Meters</span>
          <div class="toggle active" id="toggleAnalysisMeters" data-bind="showAnalysisMeters"></div>
        </div>
        <div class="setting"><span class="setting-label">Kick Sens</span><input type="range" id="sensKick"
            data-bind="sensKick" min="0.5" max="5" step="0.1" value="2.4" /></div>
        <div class="setting"><span class="setting-label">Snare Sens</span><input type="range" id="sensSnare"
            data-bind="sensSnare" min="0.5" max="5" step="0.1" value="2.2" /></div>
        <div class="setting"><span class="setting-label">HiHat Sens</span><input type="range" id="sensHihat"
            data-bind="sensHihat" min="0.5" max="5" step="0.1" value="2.0" /></div>

        <div class="group-title">Waveform</div>
        <div class="setting">
          <span class="setting-label">Stereo View</span>
          <div class="toggle active" id="toggleStereoWave" data-bind="showStereoWave"></div>
        </div>
        <div class="setting"><span class="setting-label">Wave Zoom</span><input type="range" id="waveZoom"
            data-bind="waveZoom" min="1" max="20" step="1" value="1" /></div>
      </div>

      <!-- SHARE/CAPTURE -->
      <div class="settings-panel" data-panel="share">
        <div class="group-title">Sharing & Export</div>
        <div class="setting">
          <span class="setting-label">Snapshot Res</span>
          <select id="screenshotRes">
            <option value="1x">1x (Native)</option>
            <option value="2x" selected>2x (High)</option>
            <option value="4x">4x (Ultra)</option>
          </select>
        </div>
        <div class="setting">
          <span class="setting-label">Take Snapshot</span>
          <button class="btn" id="takeSnapshot" style="font-size:10px;padding:8px 12px;">Capture Image</button>
        </div>

        <div class="group-title">Preset Sharing</div>
        <div class="setting">
          <span class="setting-label">Export Preset</span>
          <button class="btn" id="exportPreset" style="font-size:10px;padding:8px 12px;">Copy JSON</button>
        </div>
        <div class="setting">
          <span class="setting-label">Import Preset</span>
          <button class="btn" id="importPreset" style="font-size:10px;padding:8px 12px;">Paste JSON/URL</button>
        </div>

        <div class="group-title">Stream Overlay</div>
        <div class="setting"><span class="setting-label">Show Overlay</span>
          <div class="toggle" id="toggleStreamOverlay"></div>
        </div>
        <div class="setting">
          <span class="setting-label">Live Text</span>
          <input type="text" id="overlayText" value="ECHOVERSE LIVE" class="modal-preset__input"
            style="padding:4px; font-size:11px; margin-bottom:0;" />
        </div>
        <div class="setting"><span class="setting-label">Show BPM</span>
          <div class="toggle active" id="toggleBpmOverlay"></div>
        </div>
        <div class="setting"><span class="setting-label">Enable Webcam</span>
          <div class="toggle" id="toggleWebcam"></div>
        </div>
        <div class="setting"><span class="setting-label">Chroma Key</span>
          <div class="toggle" id="toggleWebcamChroma"></div>
        </div>
        <div class="setting">
          <span class="setting-label">Webcam Pos</span>
          <select id="webcamPosition">
            <option value="top-right">Top Right</option>
            <option value="top-left">Top Left</option>
            <option value="bottom-right" selected>Bottom Right</option>
            <option value="bottom-left">Bottom Left</option>
          </select>
        </div>

        <div class="group-title">Recorder Settings</div>
        <div class="setting">
          <span class="setting-label">Quality</span>
          <select id="recQuality">
            <option value="low">Low (Mobile)</option>
            <option value="medium">Medium (720p)</option>
            <option value="high" selected>High (1080p+)</option>
          </select>
        </div>
      </div>
    </div>

    <div class="controls">
      <div class="btn" style="position:relative;">
        <input type="file" accept="audio/*" id="file" class="file-input" />
        <svg viewBox="0 0 24 24">
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
          <polyline points="17 8 12 3 7 8" />
          <line x1="12" y1="3" x2="12" y2="15" />
        </svg>
      </div>
      <button class="btn btn--primary" id="playBtn">
        <svg id="playIcon" viewBox="0 0 24 24">
          <polygon points="5 3 19 12 5 21 5 3" />
        </svg>
        <svg id="pauseIcon" viewBox="0 0 24 24" style="display:none;">
          <rect x="6" y="4" width="4" height="16" />
          <rect x="14" y="4" width="4" height="16" />
        </svg>
      </button>
      <button class="btn" id="recordBtn"><svg viewBox="0 0 24 24">
          <circle cx="12" cy="12" r="6" />
        </svg></button>
      <button class="btn" id="randomBtn" title="Randomize"><svg viewBox="0 0 24 24">
          <path d="M16 3h5v5M4 20L21 3M21 16v5h-5M15 15l6 6M4 4l5 5" />
        </svg></button>
      <button class="btn" id="fullscreenBtn" title="Fullscreen"><svg viewBox="0 0 24 24">
          <path d="M8 3H5a2 2 0 00-2 2v3m18 0V5a2 2 0 00-2-2h-3m0 18h3a2 2 0 002-2v-3M3 16v3a2 2 0 002 2h3" />
        </svg></button>
    </div>

    <div class="control-footer">
      <div class="progress-bar">
        <div class="progress" id="audio-progress"></div>
      </div>
      <div class="time-display">
        <span id="current-time">0:00</span> / <span id="duration">0:00</span>
      </div>
    </div>

    <div class="footer-hint">
      <span class="hint">Space: Play · U: Hide · R: Random · F: Fullscreen · P: Presets · 1-8: Tabs</span>
    </div>
  </div>

  <audio id="audio" crossorigin="anonymous"></audio>
  <script type="module">
    import * as THREE from "three";
    import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
    import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
    import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
    import { AfterimagePass } from "three/addons/postprocessing/AfterimagePass.js";
    import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";
    import { BokehPass } from "three/addons/postprocessing/BokehPass.js";

    const TAU = Math.PI * 2;
    const clamp = (v, a, b) => Math.min(b, Math.max(a, v));
    const lerp = (a, b, t) => a + (b - a) * t;
    const fract = (x) => x - Math.floor(x);
    const hash1 = (n) => fract(Math.sin(n * 12.9898) * 43758.5453123);

    // Easing functions for smoother animations
    const easeOutQuad = (t) => t * (2 - t);
    const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);
    const easeOutExpo = (t) => t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
    const easeInOutSine = (t) => -(Math.cos(Math.PI * t) - 1) / 2;
    const smoothstep = (a, b, t) => { const x = clamp((t - a) / (b - a), 0, 1); return x * x * (3 - 2 * x); };
    const smootherstep = (a, b, t) => { const x = clamp((t - a) / (b - a), 0, 1); return x * x * x * (x * (x * 6 - 15) + 10); };

    // Helper function to format time as MM:SS
    const formatTime = (seconds) => {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    };

    // Improved noise function with better distribution
    const hash2 = (x, y) => fract(Math.sin(x * 12.9898 + y * 78.233) * 43758.5453);
    const hash3 = (x, y, z) => fract(Math.sin(x * 12.9898 + y * 78.233 + z * 45.164) * 43758.5453);

    // Perlin-like noise interpolation for smoother motion
    const fade = (t) => t * t * t * (t * (t * 6 - 15) + 10);
    const gradNoise = (x, y, z) => {
      const xi = Math.floor(x), yi = Math.floor(y), zi = Math.floor(z);
      const xf = x - xi, yf = y - yi, zf = z - zi;
      const u = fade(xf), v = fade(yf), w = fade(zf);

      const n000 = hash3(xi, yi, zi) * 2 - 1;
      const n001 = hash3(xi, yi, zi + 1) * 2 - 1;
      const n010 = hash3(xi, yi + 1, zi) * 2 - 1;
      const n011 = hash3(xi, yi + 1, zi + 1) * 2 - 1;
      const n100 = hash3(xi + 1, yi, zi) * 2 - 1;
      const n101 = hash3(xi + 1, yi, zi + 1) * 2 - 1;
      const n110 = hash3(xi + 1, yi + 1, zi) * 2 - 1;
      const n111 = hash3(xi + 1, yi + 1, zi + 1) * 2 - 1;

      return lerp(
        lerp(lerp(n000, n100, u), lerp(n010, n110, u), v),
        lerp(lerp(n001, n101, u), lerp(n011, n111, u), v),
        w
      );
    };

    const config = {
      form: 'icosahedron', density: 3, sensitivity: 1.2, volume: 0.8, visualMode: 'standard',
      colorTheme: 'void', colorPrimary: '#ffffff', colorSecondary: '#888888', colorBg: '#000000',
      colorReactivity: 0.55, colorCycle: true, hueRotateSpeed: 0, barLockColors: true,
      cameraMode: 'orbit', cameraDistance: 35, cameraSpeed: 0.6, cameraShake: 0.45, cameraFov: 60,
      cameraBeatZoom: true, cameraAutoAngles: false,
      particleMode: 'vertex', fieldMode: 'harmonic', symmetry: 6, turbulence: 0.25, cohesion: 0.55, particleCount: 1500,
      bloomStrength: 0.8, bloomRadius: 0.7, trailMode: 'medium', glitchAmount: 0,
      vignette: 0.35, grain: 0.12, aberration: 0.08, anamorphic: 0, scanlines: 0, filmLook: 'none',
      environment: 'void', fogDensity: 0.008, ringCount: 3,
      showInner: true, showOuter: true, showWaveform: true, showBars: false,
      showConnections: true, showParticles: true, showDeepParticles: true, showShockwaves: true,
      showWireframeCore: true, showRimGlow: true, showRings: true,
      particleSizeMult: 1.0, particleBrightness: 1.0,
      shockwaveIntensity: 0.7, shockwaveImpactThreshold: 0.55, shockwaveCooldown: 0.22,
      showLightRays: false, showAurora: false, showEnergyField: false, showOrbitals: false,
      showSpectrum: true, autoPilot: false, beatFlash: true,
      synesthesia: false, harmonicSnap: true, negativeSpace: false, reactiveBg: true,
      bgPattern: 'none', bgPatternStrength: 0.35,
      // NEW: Smoothness control (0 = reactive, 1 = ultra smooth)
      smoothness: 0.7,
      // Model motion controls
      modelSpinEnabled: true,
      modelSpinSpeed: 1.0,
      modelSpinAxis: 'xyz',
      modelSpinReactive: true,
      modelSpinReactivity: 1.0,
      modelPulseEnabled: true,
      modelPulseAmount: 1.0,
      // Analysis defaults
      spectrogramMode: 'off',
      analyzerFftSize: '1024',
      spectrogramColor: 'plasma',
      showAnalysisMeters: true,
      sensKick: 2.4,
      sensSnare: 2.2,
      sensHihat: 2.0,
      showStereoWave: true,
      waveZoom: 1.0,
      // Cinematic / Lighting / Grading
      lightKeyInt: 1.5,
      lightFillInt: 0.8,
      lightRimInt: 3.0,
      godRaysInt: 0.4,
      goboMode: 'none',
      renderStyle: 'wire',
      matMetal: 0.9,
      matRough: 0.1,
      gradeLift: '#000000',
      gradeGamma: '#808080',
      gradeGain: '#ffffff',
      gradeSat: 1.0,
      gradeVibrance: 1.2,
      lutInt: 0.5,
      hueRotateGrade: 0,
      // RGB Curves (0.0 to 1.0 for each control point)
      curveRShadows: 0.0, curveRMids: 0.33, curveRHighlights: 0.66, curveRWhites: 1.0,
      curveGShadows: 0.0, curveGMids: 0.33, curveGHighlights: 0.66, curveGWhites: 1.0,
      curveBShadows: 0.0, curveBMids: 0.33, curveBHighlights: 0.66, curveBWhites: 1.0,
      // Split Toning
      splitToneShadows: '#000000', splitToneHighlights: '#ffffff', splitToneBalance: 0.0,
      // Color Temperature
      colorTemp: 6500.0, // Kelvin
      tint: 0.0, // -1 to 1
      // Film Response
      filmCurve: 0, // 0=none, 1=Kodak, 2=Fuji
      // Channel Mixer (3x3 matrix)
      channelMixerRR: 1.0, channelMixerRG: 0.0, channelMixerRB: 0.0,
      channelMixerGR: 0.0, channelMixerGG: 1.0, channelMixerGB: 0.0,
      channelMixerBR: 0.0, channelMixerBG: 0.0, channelMixerBB: 1.0,
      showHDRI: true,
      // Advanced Camera System
      dofEnabled: false,
      dofFocusDistance: 35,
      dofAperture: 0.025,
      dofAutoFocus: 'center', // 'center', 'energy', 'manual'
      dofBokehScale: 2.5,
      cameraTransitionType: 'ease', // 'linear', 'ease', 'bounce', 'elastic'
      cameraTransitionDuration: 2.0,
      shakeProfile: 'none', // 'none', 'earthquake', 'explosion', 'heartbeat', 'handheld'
      shakeDirectionBias: 'xyz', // 'x', 'y', 'z', 'xy', 'xz', 'yz', 'xyz'
      shakeFrequency: 1.0,
      shakeDecay: 0.95,
      camPathRecording: false,
      camPathPlaying: false,
      camPathLoop: false,
      // Advanced Particle System
      dynamicParticlesEnabled: true,
      dynParticleCount: 2000,
      dynParticleSize: 0.15,
      dynParticleLifespan: 3.0,
      dynParticleSpawnRate: 20,
      dynParticleShape: 'circle', // 'circle', 'square', 'tri', 'star', 'mesh'
      dynParticleEmitter: 'sphere', // 'point', 'sphere', 'box', 'ring', 'mesh'
      dynParticleVelocity: 'outward', // 'outward', 'random', 'directional'
      dynParticleTrailLength: 0,
      dynForceGravity: 0.0,
      dynForceVortex: 0.0,
      dynForceTurbulence: 0.5,
      dynAttractorStrength: 1.0,
      dynCollisionEnabled: false,
      dynAudioReactiveSpawn: true,
      dynAudioVelocityMult: 1.0,
      // Social/Sharing features
      screenshotRes: '2x', // '1x', '2x', '4x'
      showStreamOverlay: false,
      overlayText: 'ECHOVERSE LIVE',
      showWebcam: false,
      webcamChromaKey: false,
      webcamPosition: 'bottom-right',
      recQuality: 'high', // 'low', 'medium', 'high'
      showBpmOverlay: true
    };

    const colorThemes = {
      void: { primary: '#ffffff', secondary: '#cccccc', bg: '#000000' },
      ember: { primary: '#ff6b35', secondary: '#ff2200', bg: '#0a0505' },
      arctic: { primary: '#88ffff', secondary: '#0066ff', bg: '#020508' },
      neon: { primary: '#ff00ff', secondary: '#00ffff', bg: '#050008' },
      sunset: { primary: '#ff8855', secondary: '#ff3366', bg: '#0a0508' },
      forest: { primary: '#88ff88', secondary: '#00aa44', bg: '#030805' },
      vapor: { primary: '#ff71ce', secondary: '#01cdfe', bg: '#05020a' },
      gold: { primary: '#ffd700', secondary: '#ff8c00', bg: '#080604' },
      blood: { primary: '#ff0044', secondary: '#880022', bg: '#0a0204' },
      ocean: { primary: '#0088ff', secondary: '#004488', bg: '#020408' },
      aurora: { primary: '#00ff88', secondary: '#ff00ff', bg: '#020804' },
      holographic: { primary: '#ff88ff', secondary: '#88ffff', bg: '#040408' },
      plasma: { primary: '#ff4488', secondary: '#888888', bg: '#080408' },
      infrared: { primary: '#ff2222', secondary: '#880044', bg: '#0a0204' },
      bioluminescent: { primary: '#00ffaa', secondary: '#0088ff', bg: '#020806' }
    };

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.15;
    document.body.appendChild(renderer.domElement);
    renderer.domElement.id = 'canvas';

    // Background Scene
    const bgScene = new THREE.Scene();
    const bgCam = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

    const bgUniforms = {
      uTime: { value: 0 }, uPhase: { value: 0 },
      uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
      uBgColor: { value: new THREE.Color(config.colorBg) },
      uAccentA: { value: new THREE.Color(config.colorPrimary) },
      uAccentB: { value: new THREE.Color(config.colorSecondary) },
      uPattern: { value: 0 }, uPatternStrength: { value: config.bgPatternStrength },
      uSymmetry: { value: config.symmetry },
      uEnergy: { value: 0 }, uBass: { value: 0 }, uMid: { value: 0 }, uHigh: { value: 0 },
      uNegative: { value: 0 }, uBeatPulse: { value: 0 }, uReactiveBg: { value: 1 }
    };

    const bgVert = `varying vec2 vUv; void main(){ vUv = uv; gl_Position = vec4(position.xy, 0.0, 1.0); }`;
    const bgFrag = `
      precision highp float;
      varying vec2 vUv;
      uniform float uTime, uPhase, uPatternStrength, uSymmetry, uEnergy, uBass, uMid, uHigh, uNegative, uBeatPulse, uReactiveBg;
      uniform vec2 uResolution;
      uniform vec3 uBgColor, uAccentA, uAccentB;
      uniform int uPattern;
      float sat(float x){ return clamp(x, 0.0, 1.0); }
      float hash(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); }
      vec3 mixScreen(vec3 a, vec3 b, float t){ return mix(a, 1.0 - (1.0 - a) * (1.0 - b), t); }
      void main(){
        vec2 uv = vUv;
        float aspect = uResolution.x / max(uResolution.y, 1.0);
        vec3 base = uBgColor;
        vec2 p = uv * 2.0 - 1.0;
        p.x *= aspect;
        float r = length(p), a = atan(p.y, p.x);
        float n = max(uSymmetry, 1.0);
        float sector = 6.28318530718 / n;
        float asym = mod(a + 3.14159265359, sector) * n;
        float ph = uPhase;
        float reactMult = uReactiveBg > 0.5 ? 1.0 : 0.0;
        float pat = 0.0;
        if (uPattern == 1) {
          pat = 0.55 * sin((10.0 + uBass * 10.0 * reactMult) * r - ph * 0.35) * cos((2.0 + uMid * 4.0 * reactMult) * asym + ph * 0.25)
              + 0.35 * sin((18.0 + uHigh * 20.0 * reactMult) * r + (3.0 + uHigh * 4.0 * reactMult) * asym - ph * 0.55);
        } else if (uPattern == 2) {
          float s = 6.0 + uMid * 10.0 * reactMult;
          float rot = ph * 0.08;
          mat2 R = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));
          vec2 q = R * p;
          float gx = abs(fract(q.x * s) - 0.5), gy = abs(fract(q.y * s) - 0.5);
          pat = (1.0 - sat(min(gx, gy) * 18.0)) * (0.6 + 0.4 * sin(ph * 0.25 + r * 3.0));
        } else if (uPattern == 3) {
          pat = 0.25 * (sin(p.x * (2.0 + uBass * 3.0 * reactMult) + ph * 0.15) + sin(p.y * (3.0 + uMid * 4.0 * reactMult) - ph * 0.12)
              + sin((p.x + p.y) * (4.0 + uHigh * 6.0 * reactMult) + ph * 0.10) + sin(r * (6.0 + uEnergy * 8.0 * reactMult) - ph * 0.08));
        } else if (uPattern == 4) {
          pat = sin(r * 8.0 - ph * 0.2) * 0.5 + sin(asym * 3.0 + ph * 0.1) * 0.3;
        } else if (uPattern == 5) {
          for (float i = 1.0; i <= 5.0; i++) {
            float freq = i * (1.0 + uEnergy * 0.5 * reactMult);
            pat += (sin(p.x * freq + ph * 0.2 * i) + sin(p.y * freq + ph * 0.15 * i)) / i;
          }
          pat *= 0.15;
        }
        float strength = uPatternStrength * (0.25 + 0.75 * uEnergy * reactMult);
        vec3 accent = mix(uAccentA, uAccentB, sat(0.5 + 0.5 * sin(ph * 0.06 + r * 2.0)));
        base = mixScreen(base, accent * (0.35 + 0.65 * sat(pat * 0.8 + 0.2)), strength);
        base += accent * uBeatPulse * 0.15 * reactMult * (1.0 - r * 0.5);
        base = mix(base, base * (0.55 + 0.45 * smoothstep(1.35, 0.15, r)), 0.70);
        base += (hash(uv * uResolution.xy + fract(uTime) * 100.0) - 0.5) * 0.03;
        if (uNegative > 0.5) base = mix(mix(base, vec3(1.0), 0.82), vec3(1.0) - base * 0.55, 0.6);
        gl_FragColor = vec4(base, 1.0);
      }
    `;
    bgScene.add(new THREE.Mesh(new THREE.PlaneGeometry(2, 2), new THREE.ShaderMaterial({ uniforms: bgUniforms, vertexShader: bgVert, fragmentShader: bgFrag, depthTest: false, depthWrite: false })));

    function setBgPatternFromConfig() {
      const map = { none: 0, mandala: 1, lattice: 2, plasma: 3, voronoi: 4, waves: 5 };
      bgUniforms.uPattern.value = map[config.bgPattern] || 0;
    }
    setBgPatternFromConfig();

    // Environment & Dynamics
    let sky, water;
    let mainGeometry;
    let keyLight, fillLight, rimLight;

    // Main Scene
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(config.colorBg, config.fogDensity);
    const camera = new THREE.PerspectiveCamera(config.cameraFov, window.innerWidth / window.innerHeight, 0.1, 500);
    camera.position.set(0, 0, config.cameraDistance);
    scene.add(new THREE.AmbientLight(0xffffff, 0.15));

    keyLight = new THREE.DirectionalLight(0xffffff, config.lightKeyInt);
    keyLight.position.set(10, 10, 10);
    scene.add(keyLight);

    fillLight = new THREE.PointLight(0x88ccff, config.lightFillInt);
    fillLight.position.set(-10, 0, 5);
    scene.add(fillLight);

    rimLight = new THREE.SpotLight(0xffffff, config.lightRimInt);
    rimLight.position.set(0, 5, -15);
    rimLight.angle = 0.6;
    scene.add(rimLight);

    const projectorLight = new THREE.SpotLight(0xffffff, 0);
    projectorLight.position.set(0, 20, 0);
    projectorLight.angle = 0.5;
    projectorLight.penumbra = 0.5;
    scene.add(projectorLight);
    // Audio Analyzer - Enhanced with better frequency mapping and transient detection
    class AudioAnalyzer {
      constructor() {
        this.bands = 64;
        this.bandValues = new Float32Array(this.bands);
        this.bandPeaks = new Float32Array(this.bands);
        // Logarithmic frequency band edges for perceptually uniform distribution
        this.bandEdges = this._computeLogBandEdges(this.bands, 20, 20000);
        this.prevBandValues = new Float32Array(this.bands);
        this.onsetDecay = new Float32Array(this.bands);
        this._fftSmooth = null;
        this.beatInterval = 500; this.lastBeatTime = 0; this.beatGate = 0;
        this.bpmSmooth = 120; this.beatCount = 0; this.barCount = 0;
        this.spectralCentroid = 0.5; this.spectralFlux = 0; this.energy = 0;
        this.spectralSpread = 0; this.spectralRolloff = 0; this.spectralFlatness = 0;
        this.onsetKick = 0; this.onsetSnare = 0; this.onsetHihat = 0; this.onsetGlobal = 0;
        this._fluxHist = []; this._fluxKickHist = []; this._fluxSnareHist = []; this._fluxHihatHist = [];
        this._lastOnsetT = 0; this._lastKickT = 0; this._lastSnareT = 0; this._lastHihatT = 0;
        this.rms = 0; this.rmsSmooth = 0.06; this.rmsPeak = 0;
        this.sampleRate = 48000; this.fftSize = 8192;
        this.rootNote = NaN; this.noteName = '--'; this.chroma = new Float32Array(12);
        this._noteBins = new Float32Array(12);
        this.smoothSubBass = 0; this.smoothBass = 0; this.smoothLowMid = 0;
        this.smoothMid = 0; this.smoothHighMid = 0; this.smoothHigh = 0; this.smoothBrilliance = 0;
        // Enhanced envelope followers with attack/release
        this._envSubBass = 0; this._envBass = 0; this._envMid = 0; this._envHigh = 0;
        this._tMs = 0;
        // Transient sharpness - how "punchy" the current moment is
        this.transientSharpness = 0;
        // Harmonic content detection
        this.harmonicRatio = 0;
      }

      _computeLogBandEdges(numBands, minHz, maxHz) {
        // Create logarithmically spaced frequency band edges for perceptual accuracy
        const edges = new Float32Array(numBands + 1);
        const logMin = Math.log10(minHz);
        const logMax = Math.log10(maxHz);
        for (let i = 0; i <= numBands; i++) {
          edges[i] = Math.pow(10, logMin + (i / numBands) * (logMax - logMin));
        }
        return edges;
      }

      setFFTInfo(fftSize, sampleRate) {
        this.fftSize = fftSize;
        this.sampleRate = sampleRate;
        this.bandEdges = this._computeLogBandEdges(this.bands, 20, Math.min(20000, sampleRate / 2));
      }
      _median(arr) { if (!arr.length) return 0; const a = arr.slice().sort((x, y) => x - y); const mid = (a.length - 1) * 0.5; return lerp(a[Math.floor(mid)], a[Math.ceil(mid)], mid - Math.floor(mid)); }
      _mad(arr, med) { return this._median(arr.map(v => Math.abs(v - med))) + 1e-6; }
      _adaptiveThreshold(history, k = 2.6) { const med = this._median(history); return med + k * this._mad(history, med); }
      _ensureFftSmooth(n) { if (!this._fftSmooth || this._fftSmooth.length !== n) this._fftSmooth = new Float32Array(n); }
      _noteName(pc) { return ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'][(pc | 0) % 12]; }

      analyze(freqData, timeData, dt, freqL = null, freqR = null, smoothingAlpha = 0.18) {
        this._tMs += dt * 1000;
        const N = freqData.length;
        this._ensureFftSmooth(N);

        // Adaptive smoothing - less smoothing during transients for sharper response
        const baseAlpha = clamp(smoothingAlpha, 0.05, 0.4);

        // Convert to normalized amplitude with proper dB scaling
        const hzPerBin = this.sampleRate / this.fftSize;
        // (perf) removed unused prev FFT copy that could cause periodic GC stutters
        for (let i = 0; i < N; i++) {
          // Convert byte to linear amplitude (0-1) with slight curve for better dynamics
          const linear = Math.pow(freqData[i] / 255, 1.2);
          // Adaptive alpha - faster attack, slower release
          const a = linear > this._fftSmooth[i] ? Math.min(baseAlpha * 2.5, 0.7) : baseAlpha;
          this._fftSmooth[i] = lerp(this._fftSmooth[i], linear, a);
        }

        // Compute logarithmic frequency bands for perceptual accuracy
        let sumEnergy = 0, sumCentroid = 0, sumCentroidWeight = 0;
        let geoMean = 0, arithmeticMean = 0;

        for (let b = 0; b < this.bands; b++) {
          const lowHz = this.bandEdges[b];
          const highHz = this.bandEdges[b + 1];
          const startBin = Math.max(1, Math.floor(lowHz / hzPerBin));
          const endBin = Math.min(N - 1, Math.ceil(highHz / hzPerBin));

          let v = 0, w = 0;
          for (let i = startBin; i <= endBin; i++) {
            // Weight by frequency for better high-frequency response
            const weight = 1.0 + (i / N) * 0.5;
            v += this._fftSmooth[i] * weight;
            w += weight;
          }
          const val = w > 0 ? v / w : 0;
          this.bandValues[b] = val;
          this.bandPeaks[b] = Math.max(this.bandPeaks[b] * 0.97, val);

          const centerHz = (lowHz + highHz) / 2;
          sumCentroid += (b / this.bands) * val;
          sumCentroidWeight += val;
          sumEnergy += val * val; // Energy as sum of squared amplitudes

          // For spectral flatness (geometric mean / arithmetic mean)
          arithmeticMean += val;
          geoMean += val > 0.001 ? Math.log(val + 0.001) : Math.log(0.001);
        }

        this.spectralCentroid = sumCentroidWeight > 1e-6 ? sumCentroid / sumCentroidWeight : 0.5;
        arithmeticMean /= this.bands;
        geoMean = Math.exp(geoMean / this.bands);
        this.spectralFlatness = arithmeticMean > 0.001 ? geoMean / arithmeticMean : 0;

        // Spectral flux - measures change in spectrum (great for onset detection)
        let flux = 0, fluxKick = 0, fluxSnare = 0, fluxHihat = 0;
        for (let b = 0; b < this.bands; b++) {
          const dv = this.bandValues[b] - this.prevBandValues[b];
          const pos = Math.max(0, dv);
          const rectified = pos * pos; // Square for emphasis on large changes
          flux += rectified;

          // Frequency-specific onset detection
          const hz = (this.bandEdges[b] + this.bandEdges[b + 1]) / 2;
          if (hz < 150) fluxKick += rectified * 2.0; // Sub-bass and bass (kick drums)
          else if (hz >= 150 && hz < 400) fluxKick += rectified * 0.5; // Upper bass
          else if (hz >= 200 && hz < 2000) fluxSnare += rectified; // Snare body
          else if (hz >= 4000) fluxHihat += rectified * 1.5; // Hi-hats and cymbals

          this.onsetDecay[b] = Math.max(this.onsetDecay[b] * 0.82, clamp(pos * 2.8, 0, 1));
          this.prevBandValues[b] = this.bandValues[b];
        }
        flux = Math.sqrt(flux);
        fluxKick = Math.sqrt(fluxKick);
        fluxSnare = Math.sqrt(fluxSnare);
        fluxHihat = Math.sqrt(fluxHihat);

        const pushHist = (arr, v, maxLen) => { arr.push(v); if (arr.length > maxLen) arr.shift(); };
        pushHist(this._fluxHist, flux, 60);
        pushHist(this._fluxKickHist, fluxKick, 50);
        pushHist(this._fluxSnareHist, fluxSnare, 50);
        pushHist(this._fluxHihatHist, fluxHihat, 40);

        // Improved onset detection with separate cooldowns for different instruments
        const now = this._tMs;
        const trigOnset = (v, thr, ref, cooldown, sensitivity = 2.4) => {
          if (v > thr && (now - this[ref]) > cooldown) {
            this[ref] = now;
            return clamp((v / thr - 1.0) * sensitivity, 0.5, 1.5); // Proportional to how much over threshold
          }
          return 0.0;
        };

        const sk = config.sensKick || 3.0;
        const ss = config.sensSnare || 2.4;
        const sh = config.sensHihat || 2.5;

        const gOn = trigOnset(flux, this._adaptiveThreshold(this._fluxHist, 2.2), '_lastOnsetT', 80);
        const kOn = trigOnset(fluxKick, this._adaptiveThreshold(this._fluxKickHist, 2.0), '_lastKickT', 150, sk);
        const sOn = trigOnset(fluxSnare, this._adaptiveThreshold(this._fluxSnareHist, 2.2), '_lastSnareT', 100, ss);
        const hOn = trigOnset(fluxHihat, this._adaptiveThreshold(this._fluxHihatHist, 2.5), '_lastHihatT', 50, sh);

        // Smoother decay with different rates per instrument type
        this.onsetGlobal = Math.max(gOn, this.onsetGlobal * 0.88);
        this.onsetKick = Math.max(kOn, this.onsetKick * 0.78); // Slower decay for punchy feel
        this.onsetSnare = Math.max(sOn, this.onsetSnare * 0.82);
        this.onsetHihat = Math.max(hOn, this.onsetHihat * 0.90); // Fast decay for hi-hats

        this.spectralFlux = clamp(flux * 0.8, 0, 2.5);

        // Transient sharpness - combination of all onset signals
        this.transientSharpness = clamp(
          this.onsetKick * 1.2 + this.onsetSnare * 0.8 + this.onsetHihat * 0.5 + this.onsetGlobal * 0.3,
          0, 2.0
        );

        // RMS with proper envelope following
        if (timeData && timeData.length) {
          let sum = 0, zeroCrossings = 0;
          for (let i = 0; i < timeData.length; i++) {
            const sample = (timeData[i] - 128) / 128;
            sum += sample * sample;
            if (i > 0) {
              const prev = (timeData[i - 1] - 128) / 128;
              if ((sample >= 0 && prev < 0) || (sample < 0 && prev >= 0)) zeroCrossings++;
            }
          }
          this.rms = Math.sqrt(sum / timeData.length);
          // Zero crossing rate hints at high frequency content
          this.harmonicRatio = clamp(zeroCrossings / timeData.length * 50, 0, 1);
        }

        // Envelope follower with faster attack, slower release
        const attackTime = 0.005, releaseTime = 0.15;
        const attackCoeff = 1 - Math.exp(-dt / attackTime);
        const releaseCoeff = 1 - Math.exp(-dt / releaseTime);
        const envCoeff = this.rms > this.rmsSmooth ? attackCoeff : releaseCoeff;
        this.rmsSmooth = this.rmsSmooth + (this.rms - this.rmsSmooth) * envCoeff;
        this.rmsPeak = Math.max(this.rmsPeak * 0.9995, this.rmsSmooth);

        // Enhanced multi-band smoothing with attack/release envelopes
        const computeBandEnergy = (startBand, endBand) => {
          let sum = 0;
          for (let i = startBand; i <= endBand && i < this.bands; i++) sum += this.bandValues[i];
          return sum / (endBand - startBand + 1);
        };

        // More frequency bands for finer control
        const rawSubBass = computeBandEnergy(0, 3);    // 20-60 Hz
        const rawBass = computeBandEnergy(4, 8);       // 60-200 Hz
        const rawLowMid = computeBandEnergy(9, 16);    // 200-600 Hz
        const rawMid = computeBandEnergy(17, 28);      // 600-2kHz
        const rawHighMid = computeBandEnergy(29, 40);  // 2k-6kHz
        const rawHigh = computeBandEnergy(41, 52);     // 6k-12kHz
        const rawBrilliance = computeBandEnergy(53, 63); // 12k-20kHz

        // Per-band envelope followers
        const updateEnv = (current, target, attack, release) => {
          const coeff = target > current ? attack : release;
          return current + (target - current) * coeff;
        };
        const fastAttack = 1 - Math.pow(0.001, dt * 12.0);
        const medAttack = 1 - Math.pow(0.001, dt * 6.0);
        const slowRelease = 1 - Math.pow(0.001, dt * 1.5);
        const medRelease = 1 - Math.pow(0.001, dt * 2.5);

        this.smoothSubBass = updateEnv(this.smoothSubBass, rawSubBass, fastAttack, slowRelease);
        this.smoothBass = updateEnv(this.smoothBass, rawBass, fastAttack, slowRelease);
        this.smoothLowMid = updateEnv(this.smoothLowMid, rawLowMid, medAttack, medRelease);
        this.smoothMid = updateEnv(this.smoothMid, rawMid, medAttack, medRelease);
        this.smoothHighMid = updateEnv(this.smoothHighMid, rawHighMid, medAttack, medRelease);
        this.smoothHigh = updateEnv(this.smoothHigh, rawHigh, fastAttack, medRelease);
        this.smoothBrilliance = updateEnv(this.smoothBrilliance, rawBrilliance, fastAttack, medRelease);

        // Composite energy with perceptual weighting
        this.energy = clamp(
          0.25 * this.smoothSubBass +
          0.30 * this.smoothBass +
          0.15 * this.smoothLowMid +
          0.15 * this.smoothMid +
          0.10 * this.smoothHighMid +
          0.05 * this.smoothHigh,
          0, 1.5
        );

        // Beat detection with tempo tracking
        let isBeat = false;
        if (kOn > 0.3 && (now - this.lastBeatTime) > 180 && this.beatGate <= 0) {
          isBeat = true;
          const interval = now - this.lastBeatTime;
          if (this.lastBeatTime > 0 && interval > 180 && interval < 2500) {
            // Weighted average with recency bias
            this.beatInterval = lerp(this.beatInterval, interval, 0.25);
            this.bpmSmooth = lerp(this.bpmSmooth, 60000 / this.beatInterval, 0.15);
          }
          this.lastBeatTime = now;
          this.beatCount++;
          if (this.beatCount % 4 === 0) this.barCount++;
          this.beatGate = 100;
        }
        this.beatGate = Math.max(0, this.beatGate - dt * 1000);

        // Chroma / pitch class detection for synesthesia
        if (this._fftSmooth) {
          this.chroma.fill(0);
          for (let i = 4; i < Math.min(400, N); i++) {
            const freq = i * hzPerBin;
            if (freq > 30 && freq < 4000) {
              const midi = 69 + 12 * Math.log2(freq / 440);
              const chroma = ((Math.round(midi) % 12) + 12) % 12;
              this.chroma[chroma] += this._fftSmooth[i];
            }
          }
          // Find dominant pitch class
          let maxVal = 0, maxIdx = 0;
          for (let i = 0; i < 12; i++) {
            if (this.chroma[i] > maxVal) { maxVal = this.chroma[i]; maxIdx = i; }
          }
          if (maxVal > 0.1) {
            this.rootNote = maxIdx;
            this.noteName = this._noteName(this.rootNote);
          }
        }
        return isBeat;
      }
      getBand(i) { return this.bandValues[Math.min(i, this.bands - 1)]; }
      getOnset(i) { return this.onsetDecay[Math.min(i, this.bands - 1)]; }
      getBPM() { return Math.round(Number.isFinite(this.bpmSmooth) ? this.bpmSmooth : 60000 / clamp(this.beatInterval, 240, 2000)); }
    }
    const audio = new AudioAnalyzer();

    // ========================================================================
    // PROFESSIONAL ANALYSIS MANAGER
    // ========================================================================
    class AnalysisManager {
      constructor() {
        this.spectrogramCanvas = document.getElementById('spectrogram-canvas');
        this.specCtx = this.spectrogramCanvas.getContext('2d');
        this.dynamicsMeters = document.getElementById('gain-reduction-meters');
        this.beatConfidence = document.getElementById('beat-confidence');

        this.waveCanvas = document.createElement('canvas');
        this.waveCtx = this.waveCanvas.getContext('2d');
        this.waveCanvas.className = 'analyzer-wave-canvas';
        document.getElementById('dynamics-visualization').appendChild(this.waveCanvas);

        this.specHistory = [];
        this.maxHistory = 120;
        this.bands8 = new Float32Array(8);
        this.gr8 = new Float32Array(8);
        this.peakHold = new Float32Array(8);
        this.peakDecay = 0.95;

        this.initMeters();
      }

      onAudioInit() {
        if (!analyserL) return;
        this.timeL = new Uint8Array(analyserL.fftSize);
        this.timeR = new Uint8Array(analyserR.fftSize);
      }

      initMeters() {
        this.dynamicsMeters.innerHTML = '';
        for (let i = 0; i < 8; i++) {
          const meter = document.createElement('div');
          meter.className = 'analyzer-meter';
          const bar = document.createElement('div');
          bar.className = 'gr-bar';
          meter.appendChild(bar);
          this.dynamicsMeters.appendChild(meter);
        }

        this.beatConfidence.innerHTML = '';
        ['Kick', 'Snare', 'Hi-Hat', 'Perc'].forEach(name => {
          const row = document.createElement('div');
          row.className = 'analyzer-row';
          const label = document.createElement('span');
          label.textContent = name;
          label.className = 'analyzer-label';
          const track = document.createElement('div');
          track.className = 'analyzer-track';
          const bar = document.createElement('div');
          bar.id = `conf-${name.toLowerCase().replace('-', '')}`;
          bar.className = 'analyzer-conf-bar';
          track.appendChild(bar);
          row.appendChild(label);
          row.appendChild(track);
          this.beatConfidence.appendChild(row);
        });
      }

      update(audio, dt) {
        if (!analyser) return;

        if (playing) {
          if (analyserL) analyserL.getByteTimeDomainData(this.timeL);
          if (analyserR) analyserR.getByteTimeDomainData(this.timeR);
        }

        // 1. Spectrogram update
        const currentSpec = new Uint8Array(audio.bands);
        for (let i = 0; i < audio.bands; i++) currentSpec[i] = audio.bandValues[i] * 255;
        this.specHistory.push(currentSpec);
        if (this.specHistory.length > this.maxHistory) this.specHistory.shift();

        if (config.spectrogramMode && config.spectrogramMode !== 'off') {
          this.drawSpectrogram();
        } else {
          this.spectrogramCanvas.style.display = 'none';
        }

        // 2. Dynamics processing visualization (8-band splitter representation)
        const bandSize = Math.floor(audio.bands / 8);
        for (let i = 0; i < 8; i++) {
          let sum = 0;
          for (let j = 0; j < bandSize; j++) sum += audio.bandValues[i * bandSize + j];
          const val = sum / bandSize;
          this.bands8[i] = val;

          // Gain reduction logic simulation
          const threshold = 0.35;
          const reduction = Math.max(0, (val - threshold) * 1.5);
          this.gr8[i] = lerp(this.gr8[i], reduction, 0.15);
        }

        if (config.showAnalysisMeters) {
          document.getElementById('dynamics-visualization').style.display = 'flex';
          this.updateMeters();
          this.drawWaveform();
        } else {
          document.getElementById('dynamics-visualization').style.display = 'none';
        }
      }

      updateMeters() {
        const bars = this.dynamicsMeters.querySelectorAll('.gr-bar');
        bars.forEach((bar, i) => {
          bar.style.height = `${clamp(this.gr8[i] * 100, 0, 100)}%`;
          bar.style.opacity = 0.3 + this.gr8[i] * 0.7;
        });

        // Update RMS/Peak text
        document.getElementById('rms-val').textContent = audio.rmsSmooth.toFixed(3);
        document.getElementById('peak-val').textContent = audio.rmsPeak.toFixed(3);

        const confs = {
          kick: audio.onsetKick,
          snare: audio.onsetSnare,
          hihat: audio.onsetHihat,
          perc: audio.onsetGlobal
        };
        for (const k in confs) {
          const el = document.getElementById(`conf-${k}`);
          if (el) {
            const confVal = clamp(confs[k] * 100, 0, 100);
            el.style.width = `${confVal}%`;
            el.style.boxShadow = confs[k] > 0.6 ? '0 0 10px #fff' : 'none';
            el.style.background = confs[k] > 0.8 ? '#fff' : (confs[k] > 0.4 ? '#888' : '#444');
          }
        }
      }

      drawWaveform() {
        const w = this.waveCanvas.width = this.waveCanvas.clientWidth;
        const h = this.waveCanvas.height = this.waveCanvas.clientHeight;
        const ctx = this.waveCtx;
        ctx.clearRect(0, 0, w, h);
        if (!this.timeL) return;

        const bufferLength = this.timeL.length;
        const zoom = config.waveZoom || 1;
        const visibleSamples = Math.floor(bufferLength / zoom);
        const start = Math.floor((bufferLength - visibleSamples) / 2);
        const sliceWidth = w / visibleSamples;

        // Draw Left
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#fff';
        ctx.shadowBlur = 5; ctx.shadowColor = '#fff';
        ctx.beginPath();
        for (let i = 0; i < visibleSamples; i++) {
          const val = (this.timeL[start + i] - 128) / 128;
          const y = (config.showStereoWave ? h * 0.3 : h * 0.5) + val * (h * 0.4);
          if (i === 0) ctx.moveTo(i * sliceWidth, y);
          else ctx.lineTo(i * sliceWidth, y);
        }
        ctx.stroke();

        // Draw Right
        if (config.showStereoWave && this.timeR) {
          ctx.strokeStyle = '#888';
          ctx.shadowColor = '#888';
          ctx.beginPath();
          for (let i = 0; i < visibleSamples; i++) {
            const val = (this.timeR[start + i] - 128) / 128;
            const y = h * 0.7 + val * (h * 0.4);
            if (i === 0) ctx.moveTo(i * sliceWidth, y);
            else ctx.lineTo(i * sliceWidth, y);
          }
          ctx.stroke();
        }
        ctx.shadowBlur = 0;
      }

      drawSpectrogram() {
        this.spectrogramCanvas.style.display = 'block';
        const w = this.spectrogramCanvas.width = this.spectrogramCanvas.clientWidth;
        const h = this.spectrogramCanvas.height = this.spectrogramCanvas.clientHeight;
        const ctx = this.specCtx;
        const mode = config.spectrogramMode;
        const colorMode = config.spectrogramColor;

        ctx.fillStyle = '#000'; ctx.fillRect(0, 0, w, h);

        const rows = this.specHistory.length;
        const cols = audio.bands;

        if (mode === 'horizontal') {
          const cellW = w / rows; const cellH = h / cols;
          this.specHistory.forEach((line, r) => {
            line.forEach((val, c) => {
              if (val < 10) return;
              ctx.fillStyle = this.getColorMap(val, colorMode);
              ctx.fillRect(r * cellW, h - (c * cellH), cellW + 1, cellH + 1);
            });
          });
        } else {
          const cellW = w / cols; const cellH = h / rows;
          this.specHistory.forEach((line, r) => {
            line.forEach((val, c) => {
              if (val < 10) return;
              ctx.fillStyle = this.getColorMap(val, colorMode);
              ctx.fillRect(c * cellW, h - (r * cellH), cellW + 1, cellH + 1);
            });
          });
        }
      }

      getColorMap(v, mode) {
        v /= 255;
        if (mode === 'grayscale') return `rgb(${v * 255},${v * 255},${v * 255})`;
        if (mode === 'heatmap') return `rgb(${v * 255}, ${clamp((v - 0.3) * 400, 0, 255)}, ${clamp((v - 0.7) * 800, 0, 255)})`;
        if (mode === 'plasma') return `hsl(${(280 + v * 120) % 360}, ${70 + v * 30}%, ${v * 60 + 20}%)`;
        if (mode === 'viridis') return `rgb(${v * 68}, ${v * 190}, ${v * 158})`;
        return `rgb(${v * 255},${v * 255},${v * 255})`;
      }
    }
    window.analysisManager = new AnalysisManager();

    // ========================================================================
    // MOTION COORDINATOR V2 - Ultra-smooth motion with configurable smoothness
    // ========================================================================
    class MotionCoordinator {
      constructor() {
        // === OUTPUT VALUES (what visual elements should READ) ===
        this.pulse = 0;           // Main beat pulse (0-1)
        this.impact = 0;          // Sharp transients (0-1)
        this.swell = 0;           // Sustained energy (0-1), VERY slow
        this.breathe = 0;         // Bar-locked breathing (0-1)

        // Frequency motion (heavily smoothed)
        this.lowMotion = 0;
        this.midMotion = 0;
        this.highMotion = 0;

        // Pre-computed suggestions
        this.scaleSuggestion = 1;
        this.zoomSuggestion = 0;

        // === INTERNAL: Raw targets (before smoothing) ===
        this._pulseRaw = 0;
        this._impactRaw = 0;
        this._swellRaw = 0;
        this._lowRaw = 0;
        this._midRaw = 0;
        this._highRaw = 0;

        // === INTERNAL: Second-order smoothing (for extra smoothness) ===
        this._pulseSmooth1 = 0;
        this._pulseSmooth2 = 0;
        this._swellSmooth1 = 0;
        this._swellSmooth2 = 0;

        // === INTERNAL: Timing ===
        this._lastBeatTime = 0;
        this._beatLockout = 0;
        this._breathePhase = 0;
      }

      update(audio, dt, musicPhase, smoothness = 0.7) {
        const now = performance.now();

        // Smoothness affects all lerp rates
        // smoothness 0 = reactive (fast lerps)
        // smoothness 1 = ultra smooth (very slow lerps)
        const smoothFactor = 0.3 + smoothness * 0.7; // 0.3 to 1.0
        const lerpSlow = dt * (1.5 - smoothFactor * 1.2);   // 1.5 to 0.3
        const lerpMed = dt * (4.0 - smoothFactor * 3.0);    // 4.0 to 1.0
        const lerpFast = dt * (8.0 - smoothFactor * 5.0);   // 8.0 to 3.0

        // === BEAT PULSE ===
        // Longer lockout at higher smoothness to prevent rapid beats
        const beatLockoutTime = 150 + smoothness * 200; // 150-350ms

        if (audio.onsetKick > 0.4 && this._beatLockout <= 0) {
          // Scale pulse intensity by how strong the beat is
          this._pulseRaw = clamp(audio.onsetKick * 0.9, 0.5, 1.0);
          this._beatLockout = beatLockoutTime;
          this._lastBeatTime = now;
        }
        this._beatLockout = Math.max(0, this._beatLockout - dt * 1000);

        // Decay rate affected by smoothness
        const pulseDecayRate = 0.92 + smoothness * 0.06; // 0.92 to 0.98
        this._pulseRaw *= pulseDecayRate;

        // TWO-STAGE smoothing for pulse (removes jitter)
        this._pulseSmooth1 = lerp(this._pulseSmooth1, this._pulseRaw, lerpFast);
        this._pulseSmooth2 = lerp(this._pulseSmooth2, this._pulseSmooth1, lerpMed);
        this.pulse = this._pulseSmooth2;

        // === IMPACT (sharp transients) ===
        // At high smoothness, we basically disable sharp transients
        const impactInfluence = 1.0 - smoothness * 0.8; // 1.0 to 0.2
        const rawImpact = (audio.onsetSnare * 0.5 + audio.onsetHihat * 0.3) * impactInfluence;
        this._impactRaw = Math.max(this._impactRaw * 0.9, rawImpact);
        this.impact = lerp(this.impact, this._impactRaw, lerpFast);

        // === SWELL (sustained energy) ===
        // This is intentionally VERY slow - tracks overall song energy
        const targetSwell = audio.energy * 0.7 + audio.rmsSmooth * 0.3;
        this._swellRaw = lerp(this._swellRaw, targetSwell, dt * (0.5 - smoothness * 0.35)); // Very slow

        // Two-stage smoothing for swell
        this._swellSmooth1 = lerp(this._swellSmooth1, this._swellRaw, lerpSlow);
        this._swellSmooth2 = lerp(this._swellSmooth2, this._swellSmooth1, lerpSlow);
        this.swell = this._swellSmooth2;

        // === BREATHE (tempo-locked gentle motion) ===
        const bpm = audio.getBPM() || 120;
        this._breathePhase += dt * (bpm / 60) * 0.25; // Quarter-note cycle
        // Sine wave breathing, scaled by swell
        this.breathe = (Math.sin(this._breathePhase * Math.PI * 2) * 0.5 + 0.5) * this.swell * 0.7;

        // === FREQUENCY BANDS (heavily smoothed) ===
        const lowTarget = (audio.smoothSubBass + audio.smoothBass) * 0.5;
        const midTarget = (audio.smoothLowMid + audio.smoothMid) * 0.5;
        const highTarget = (audio.smoothHighMid + audio.smoothHigh) * 0.5;

        // Extra smoothing layer
        this._lowRaw = lerp(this._lowRaw, lowTarget, lerpMed);
        this._midRaw = lerp(this._midRaw, midTarget, lerpMed);
        this._highRaw = lerp(this._highRaw, highTarget, lerpMed);

        // Final output with additional smoothing
        this.lowMotion = lerp(this.lowMotion, this._lowRaw, lerpSlow);
        this.midMotion = lerp(this.midMotion, this._midRaw, lerpSlow);
        this.highMotion = lerp(this.highMotion, this._highRaw, lerpSlow);

        // === PRE-COMPUTED SUGGESTIONS ===
        // Scale: gentle pulse + subtle swell + breathing
        const pulseScale = this.pulse * (0.2 - smoothness * 0.12); // 0.2 to 0.08
        const swellScale = this.swell * 0.12;
        const breatheScale = this.breathe * 0.06;
        this.scaleSuggestion = 1.0 + pulseScale + swellScale + breatheScale;

        // Zoom: very subtle, mostly breathing-based at high smoothness
        const pulseZoom = this.pulse * (0.12 - smoothness * 0.10); // 0.12 to 0.02
        this.zoomSuggestion = -pulseZoom + this.breathe * 0.04;
      }

      // Get a value with extra smoothing applied
      getSmoothed(value, extraSmooth = 0.5) {
        return value * (1.0 - extraSmooth);
      }
    }
    const motion = new MotionCoordinator();

    // ========================================================================
    // PARTICLE PHYSICS WORKER - Inline Blob for thread safety
    // ========================================================================
    const PARTICLE_WORKER_CODE = `
      self.onmessage = function(e) {
        const { particles, dt, energy, mode } = e.data;
        for (let i = 0; i < particles.length; i++) {
          const p = particles[i];
          if (p.life <= 0) continue;
          p.life -= dt;
          
          let fx = 0, fy = 0, fz = 0;
          if (mode === 'stardust') {
            const r = Math.sqrt(p.x*p.x + p.z*p.z);
            const a = Math.atan2(p.z, p.x) + dt * (0.5 + energy);
            p.x = Math.cos(a) * r; p.z = Math.sin(a) * r;
          } else if (mode === 'neon-rain') {
            fy = -15.0;
          } else if (mode === 'quantum') {
            if (Math.random() < 0.02 * energy) {
              p.x += (Math.random()-0.5)*20; p.y += (Math.random()-0.5)*20; p.z += (Math.random()-0.5)*20;
            }
          } else if (mode === 'filament') {
            fx = -p.x * 0.5; fy = -p.y * 0.5; fz = -p.z * 0.5;
          } else if (mode === 'swarm') {
            const d = Math.sqrt(p.x*p.x + p.y*p.y + p.z*p.z);
            fx = (Math.random()-0.5)*10 + (Math.sin(p.y*0.1 + dt)*5);
            fy = (Math.random()-0.5)*10;
            fz = (Math.random()-0.5)*10 + (Math.cos(p.x*0.1)*5);
            if (d > 50) { fx -= p.x*0.5; fy -= p.y*0.5; fz -= p.z*0.5; }
          } else if (mode === 'orbital') {
            const d = Math.sqrt(p.x*p.x + p.z*p.z);
            const ang = Math.atan2(p.z, p.x) + dt * (1.0 + 50.0 / (d + 1.0));
            p.x = Math.cos(ang) * d; p.z = Math.sin(ang) * d;
            p.y += (Math.random()-0.5) * 0.5;
            if (Math.abs(p.y) > 20) p.vy -= p.y * 0.1;
          }

          p.vx += fx * dt; p.vy += fy * dt; p.vz += fz * dt;
          p.x += p.vx * dt; p.y += p.vy * dt; p.z += p.vz * dt;

          if (p.y < -25) { p.y = -25; p.vy *= -0.4; }
          const d = Math.sqrt(p.x*p.x + p.y*p.y + p.z*p.z);
          if (d > 70) {
            const f = 70 / d;
            p.x *= f; p.y *= f; p.z *= f;
            p.vx *= -0.3; p.vy *= -0.3; p.vz *= -0.3;
          }
        }
        self.postMessage({ updated: particles });
      };
    `;

    class DynamicParticleSystem {
      constructor() {
        const isMobile = (navigator.hardwareConcurrency || 4) <= 4;
        this.maxParticles = isMobile ? 5000 : 15000;
        this.activeCount = 0;
        this.particles = [];
        this.pool = [];
        this.historicalPos = Array.from({ length: this.maxParticles }, () => new Float32Array(16 * 3));
        this.histIdx = new Int32Array(this.maxParticles).fill(0);

        this.container = new THREE.Group();
        scene.add(this.container);

        this.mat = new THREE.ShaderMaterial({
          uniforms: {
            uTime: { value: 0 },
            uBass: { value: 0 }, uTreble: { value: 0 },
            uEnergy: { value: 0 }, uPixelRatio: { value: window.devicePixelRatio || 1 }
          },
          vertexShader: `
            attribute vec3 velocity;
            attribute float life;
            attribute vec3 customColor;
            varying vec3 vColor;
            varying float vLife;
            uniform float uBass, uEnergy, uPixelRatio;
            void main() {
              vColor = customColor;
              vLife = life;
              vec3 pos = position + velocity * 0.02;
              vec4 mvPos = modelViewMatrix * instanceMatrix * vec4(pos, 1.0);
              gl_PointSize = (15.0 + uBass * 100.0) * (600.0 / -mvPos.z) * uPixelRatio;
              gl_Position = projectionMatrix * mvPos;
            }
          `,
          fragmentShader: `
            varying vec3 vColor;
            varying float vLife;
            uniform float uTreble;
            void main() {
              float d = length(gl_PointCoord - 0.5);
              if (d > 0.5) discard;
              float g = exp(-d * 8.0);
              gl_FragColor = vec4(vColor * (1.0 + uTreble * 3.0), vLife * g);
            }
          `,
          transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
        });

        const geom = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3()]);
        this.mesh = new THREE.InstancedMesh(geom, this.mat, this.maxParticles);
        this.mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

        this.vArr = new Float32Array(this.maxParticles * 3);
        this.lArr = new Float32Array(this.maxParticles);
        this.cArr = new Float32Array(this.maxParticles * 3);
        this.mesh.geometry.setAttribute('velocity', new THREE.InstancedBufferAttribute(this.vArr, 3));
        this.mesh.geometry.setAttribute('life', new THREE.InstancedBufferAttribute(this.lArr, 1));
        this.mesh.geometry.setAttribute('customColor', new THREE.InstancedBufferAttribute(this.cArr, 3));
        this.container.add(this.mesh);

        const tGeom = new THREE.BufferGeometry();
        this.tPos = new Float32Array(this.maxParticles * 16 * 3 * 2);
        this.tCol = new Float32Array(this.maxParticles * 16 * 3 * 2);
        tGeom.setAttribute('position', new THREE.BufferAttribute(this.tPos, 3));
        tGeom.setAttribute('color', new THREE.BufferAttribute(this.tCol, 3));
        this.trailMesh = new THREE.LineSegments(tGeom, new THREE.LineBasicMaterial({ vertexColors: true, transparent: true, blending: THREE.AdditiveBlending, opacity: 0.4 }));
        this.container.add(this.trailMesh);

        const blob = new Blob([PARTICLE_WORKER_CODE], { type: 'application/javascript' });
        this.worker = new Worker(URL.createObjectURL(blob));
        this.worker.onmessage = (e) => { this.particles = e.data.updated; };

        this.tMat = new THREE.Matrix4();
        this.tVec = new THREE.Vector3();
        this.spawnTimer = 0;
      }

      spawn(patt, count = 1) {
        for (let i = 0; i < count; i++) {
          if (this.activeCount >= this.maxParticles) return;
          const p = this.pool.length > 0 ? this.pool.pop() : { x: 0, y: 0, z: 0, vx: 0, vy: 0, vz: 0, life: 1 };
          p.life = 1.0 + Math.random() * 2.5;
          if (patt === 'radial') {
            const a = Math.random() * TAU, s = 5 + Math.random() * 8;
            p.x = 0; p.y = 0; p.z = 0; p.vx = Math.cos(a) * s; p.vy = (Math.random() - 0.5) * 10; p.vz = Math.sin(a) * s;
          } else if (patt === 'vortex') {
            const a = Math.random() * TAU; p.x = Math.cos(a) * 15; p.y = (Math.random() - 0.5) * 30; p.z = Math.sin(a) * 15;
            p.vx = -p.z * 1.2; p.vy = 0; p.vz = p.x * 1.2;
          } else {
            p.x = (Math.random() - 0.5) * 120; p.y = 60; p.z = (Math.random() - 0.5) * 120;
            p.vx = 0; p.vy = -20 - Math.random() * 20; p.vz = 0;
          }
          this.particles.push(p);
          this.activeCount++;
        }
      }

      update(dt, t, audio) {
        if (!config.dynamicParticlesEnabled) { this.container.visible = false; return; }
        this.container.visible = true;
        const rate = config.dynParticleSpawnRate * (config.dynAudioReactiveSpawn ? (1 + audio.onsetGlobal * 4) : 1);
        this.spawnTimer += dt;
        if (this.spawnTimer > 1 / rate) {
          const pat = ['radial', 'vortex', 'matrix'][Math.floor(Math.random() * 3)];
          this.spawn(pat, Math.ceil(rate * dt));
          this.spawnTimer = 0;
        }
        this.worker.postMessage({ particles: this.particles, dt, energy: audio.energy, mode: config.particleMode || 'stardust' });
        this.mat.uniforms.uBass.value = audio.smoothBass;
        this.mat.uniforms.uTreble.value = audio.smoothHigh;
        this.mat.uniforms.uEnergy.value = audio.energy;
        this.mat.uniforms.uTime.value = t;

        let tIdx = 0;
        for (let i = 0; i < this.particles.length; i++) {
          const p = this.particles[i];
          if (p.life <= 0) {
            this.pool.push(p);
            // Swap and pop
            this.particles[i] = this.particles[this.particles.length - 1];
            this.particles.pop();
            this.histIdx[i] = this.histIdx[this.particles.length]; // Sync history index if needed
            this.activeCount--; i--; continue;
          }
          this.tVec.set(p.x, p.y, p.z);
          this.tMat.setPosition(this.tVec);
          this.mesh.setMatrixAt(i, this.tMat);
          this.vArr[i * 3] = p.vx; this.vArr[i * 3 + 1] = p.vy; this.vArr[i * 3 + 2] = p.vz;
          this.lArr[i] = p.life;
          this.cArr[i * 3] = 1; this.cArr[i * 3 + 1] = 0.4 + audio.energy * 0.6; this.cArr[i * 3 + 2] = 1;

          if (config.dynParticleTrailLength > 0) {
            const h = this.historicalPos[i];
            const ptr = (this.histIdx[i] % 16) * 3;
            h[ptr] = p.x; h[ptr + 1] = p.y; h[ptr + 2] = p.z;
            this.histIdx[i]++;
            const count = Math.min(this.histIdx[i], 16);
            for (let j = 1; j < count; j++) {
              const a = ((this.histIdx[i] - j) % 16) * 3, b = ((this.histIdx[i] - j - 1) % 16) * 3;
              this.tPos[tIdx * 6] = h[a]; this.tPos[tIdx * 6 + 1] = h[a + 1]; this.tPos[tIdx * 6 + 2] = h[a + 2];
              this.tPos[tIdx * 6 + 3] = h[b]; this.tPos[tIdx * 6 + 4] = h[b + 1]; this.tPos[tIdx * 6 + 5] = h[b + 2];
              const c = 0.3 * (1 - j / 16);
              this.tCol[tIdx * 6] = this.tCol[tIdx * 6 + 3] = c; this.tCol[tIdx * 6 + 1] = this.tCol[tIdx * 6 + 4] = c; this.tCol[tIdx * 6 + 2] = this.tCol[tIdx * 6 + 5] = c;
              tIdx++;
            }
          }
        }
        this.mesh.instanceMatrix.needsUpdate = true;
        this.mesh.geometry.attributes.velocity.needsUpdate = true;
        this.mesh.geometry.attributes.life.needsUpdate = true;
        this.mesh.geometry.attributes.customColor.needsUpdate = true;
        this.mesh.count = Math.max(0, this.activeCount);
        if (config.dynParticleTrailLength > 0) {
          this.trailMesh.visible = true;
          this.trailMesh.geometry.setDrawRange(0, tIdx * 2);
          this.trailMesh.geometry.attributes.position.needsUpdate = true;
          this.trailMesh.geometry.attributes.color.needsUpdate = true;
        } else { this.trailMesh.visible = false; }
      }
    }
    const dynamicParticles = new DynamicParticleSystem();


    const music = { beats: 0, phase: 0, bpmSmooth: 120, lastSeenBar: -1 };
    const shockState = { lastTime: -1e9 };
    function updateMusicClock(dt) {
      const bpm = audio.getBPM() || 120;
      music.bpmSmooth = lerp(music.bpmSmooth, bpm, 0.08);
      music.beats += dt * (clamp(music.bpmSmooth, 50, 220) / 60);
      music.phase = music.beats * TAU;
    }
    // Geometry
    function createParametricGeometry(func, slices, stacks, scale = 8) {
      const geometry = new THREE.BufferGeometry();
      const vertices = [], indices = [];
      for (let i = 0; i <= stacks; i++) {
        const v = i / stacks;
        for (let j = 0; j <= slices; j++) {
          const u = j / slices, point = func(u, v);
          vertices.push(point.x * scale, point.y * scale, point.z * scale);
        }
      }
      for (let i = 0; i < stacks; i++) for (let j = 0; j < slices; j++) {
        const a = i * (slices + 1) + j, b = a + slices + 1;
        indices.push(a, b, a + 1, b, b + 1, a + 1);
      }
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.setIndex(indices);
      geometry.computeVertexNormals();
      return geometry;
    }

    function createGeometry(type, detail) {
      const segments = 8 + detail * 8;
      switch (type) {
        case 'icosahedron': return new THREE.IcosahedronGeometry(8, detail);
        case 'octahedron': return new THREE.OctahedronGeometry(9, detail);
        case 'tetrahedron': return new THREE.TetrahedronGeometry(10, detail);
        case 'dodecahedron': return new THREE.DodecahedronGeometry(8, detail);
        case 'torus': return new THREE.TorusGeometry(6, 2.5, 12 * detail, 24 * detail);
        case 'torusKnot': return new THREE.TorusKnotGeometry(5, 1.5, 64 * detail, 8 * detail);
        case 'sphere': return new THREE.SphereGeometry(8, 16 * detail, 16 * detail);
        case 'hyperboloid': return createParametricGeometry((u, v) => {
          const theta = u * TAU, t = (v - 0.5) * 3;
          return { x: Math.sqrt(1 + t * t) * Math.cos(theta), y: t, z: Math.sqrt(1 + t * t) * Math.sin(theta) };
        }, segments, segments, 5);
        case 'mobius': return createParametricGeometry((u, v) => {
          const theta = u * TAU, w = (v - 0.5) * 2, r = 2 + w * Math.cos(theta / 2);
          return { x: r * Math.cos(theta), y: w * Math.sin(theta / 2), z: r * Math.sin(theta) };
        }, segments * 2, Math.max(4, detail * 2), 3);
        case 'kleinBottle': return createParametricGeometry((u, v) => {
          const theta = u * TAU, phi = v * TAU, rr = 4;
          let x, y, z;
          if (theta < Math.PI) { x = 6 * Math.cos(theta) * (1 + Math.sin(theta)) + rr * (1 - Math.cos(theta) / 2) * Math.cos(theta) * Math.cos(phi); z = 16 * Math.sin(theta) + rr * (1 - Math.cos(theta) / 2) * Math.sin(theta) * Math.cos(phi); }
          else { x = 6 * Math.cos(theta) * (1 + Math.sin(theta)) + rr * (1 - Math.cos(theta) / 2) * Math.cos(phi + Math.PI); z = 16 * Math.sin(theta); }
          y = rr * (1 - Math.cos(theta) / 2) * Math.sin(phi);
          return { x: x * 0.25, y: y * 0.25, z: (z - 8) * 0.25 };
        }, segments * 2, segments, 4);
        case 'gyroid': return createParametricGeometry((u, v) => {
          const theta = u * TAU, phi = v * Math.PI;
          const r = 1 + 0.3 * (Math.sin(theta * 2) * Math.cos(phi * 3) + Math.sin(phi * 2) * Math.cos(theta * 3) + Math.sin(theta * 3) * Math.sin(phi * 2));
          return { x: r * Math.sin(phi) * Math.cos(theta), y: r * Math.cos(phi), z: r * Math.sin(phi) * Math.sin(theta) };
        }, segments * 2, segments * 2, 6);
        case 'cliffordTorus': return createParametricGeometry((u, v) => {
          const theta = u * TAU, phi = v * TAU, rr = 0.7071;
          const ww = rr * Math.cos(theta), x = rr * Math.sin(theta), y = rr * Math.cos(phi), z = rr * Math.sin(phi);
          const scale = 1 / (1 - ww + 0.01);
          return { x: x * scale, y: y * scale, z: z * scale };
        }, segments * 2, segments * 2, 4);
        case 'hopfFibration': return createParametricGeometry((u, v) => {
          const theta = u * TAU * 2, phi = v * TAU, rr = 1.5;
          return { x: rr * (Math.cos(theta) + Math.cos(phi) * Math.cos(theta + phi)), y: rr * (Math.sin(theta) + Math.cos(phi) * Math.sin(theta + phi)), z: rr * Math.sin(phi) };
        }, segments * 3, segments * 2, 3);
        case 'seashell': return createParametricGeometry((u, v) => {
          const theta = u * TAU * 3, s = v * TAU;
          const W = (s / TAU) * Math.exp(theta / (TAU * 2));
          return { x: W * Math.cos(theta) * (1 + Math.cos(s)) * 2, y: W * Math.sin(theta) * (1 + Math.cos(s)) * 2, z: (W * Math.sin(s) - 0.2 * Math.pow(theta / TAU, 2)) * 2 + 4 };
        }, segments * 3, segments, 2);
        case 'diniSurface': return createParametricGeometry((u, v) => {
          const aa = 1, b = 0.2, uu = u * TAU * 2, vv = 0.01 + v * 1.5;
          return { x: aa * Math.cos(uu) * Math.sin(vv), y: aa * Math.sin(uu) * Math.sin(vv), z: (aa * (Math.cos(vv) + Math.log(Math.tan(vv / 2))) + b * uu) * 0.3 };
        }, segments * 2, segments, 3);
        default: return new THREE.IcosahedronGeometry(8, detail);
      }
    }

    let wireframeMesh, particleSystem, connectionLines, rimMesh, vertexData = [];
    let innerMesh, outerMesh, rings = [], envObjects = [], floatingParticles, floatingData = [];
    let waveformRing, freqBars = [], lightRays = [], auroraLayer, energyFieldMesh, orbitalRings = [];
    const shockwaves = [];

    function buildMainGeometry() {
      if (wireframeMesh) scene.remove(wireframeMesh);
      if (rimMesh) scene.remove(rimMesh);
      if (particleSystem) scene.remove(particleSystem);
      if (connectionLines) scene.remove(connectionLines);

      const geom = createGeometry(config.form, config.density);

      const isWire = config.renderStyle === 'wire';
      const isPhysic = config.renderStyle === 'physic';

      let mainMat;
      if (isWire) {
        mainMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.35, blending: THREE.AdditiveBlending });
        wireframeMesh = new THREE.LineSegments(new THREE.WireframeGeometry(geom), mainMat);
      } else if (isPhysic) {
        mainMat = new THREE.MeshPhysicalMaterial({
          color: 0xffffff,
          metalness: config.matMetal,
          roughness: config.matRough,
          envMapIntensity: 1.0,
          clearcoat: 1.0,
          emissive: new THREE.Color(config.colorPrimary).multiplyScalar(0.1),
          transparent: true,
          opacity: 0.9
        });
        wireframeMesh = new THREE.Mesh(geom, mainMat);
      } else {
        mainMat = new THREE.MeshStandardMaterial({
          color: 0xffffff,
          metalness: 0.5,
          roughness: 0.5,
          wireframe: false
        });
        wireframeMesh = new THREE.Mesh(geom, mainMat);
      }

      wireframeMesh.visible = config.showWireframeCore;
      scene.add(wireframeMesh);

      const rimVert = 'varying vec3 vN, vW, vPos; void main(){ vN = normalize(normalMatrix * normal); vW = (modelMatrix * vec4(position, 1.0)).xyz; vPos = position; gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0); }';
      const rimFrag = 'uniform vec3 uColor; uniform float uIntensity, uPower, uTime; varying vec3 vN, vW, vPos; void main(){ vec3 V = normalize(cameraPosition - vW); float fres = pow(1.0 - clamp(dot(normalize(vN), V), 0.0, 1.0), uPower); float irid = sin(length(vPos) * 3.0 + uTime * 2.0) * 0.5 + 0.5; vec3 col = mix(uColor, uColor * vec3(1.2, 0.9, 1.1), irid * 0.3); gl_FragColor = vec4(col * fres * uIntensity, fres * 0.85); }';
      rimMesh = new THREE.Mesh(geom, new THREE.ShaderMaterial({
        uniforms: { uColor: { value: new THREE.Color(1, 1, 1) }, uIntensity: { value: 1.0 }, uPower: { value: 2.6 }, uTime: { value: 0 } },
        vertexShader: rimVert, fragmentShader: rimFrag,
        transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
      }));
      rimMesh.visible = config.showRimGlow;
      scene.add(rimMesh);

      const posArr = geom.attributes.position.array;
      const uniqueSet = new Set();
      vertexData = [];
      for (let i = 0; i < posArr.length; i += 3) {
        const key = `${posArr[i].toFixed(2)}, ${posArr[i + 1].toFixed(2)}, ${posArr[i + 2].toFixed(2)}`;
        if (!uniqueSet.has(key)) {
          uniqueSet.add(key);
          const v = new THREE.Vector3(posArr[i], posArr[i + 1], posArr[i + 2]);
          const norm = v.clone().normalize();
          vertexData.push({
            base: v.clone(), current: v.clone(), velocity: new THREE.Vector3(),
            band: Math.floor(((Math.atan2(norm.z, norm.x) + Math.PI) / TAU) * 32 + (Math.acos(clamp(norm.y, -1, 1)) / Math.PI) * 32) % 64,
            phase: Math.random() * TAU, theta: Math.atan2(norm.z, norm.x), phi: Math.acos(clamp(norm.y, -1, 1)), isExtra: false
          });
        }
      }
      while (vertexData.length < config.particleCount) {
        const theta = Math.random() * TAU, phi = Math.acos(2 * Math.random() - 1), r = 2 + Math.random() * 8;
        const v = new THREE.Vector3(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
        vertexData.push({
          base: v.clone(), current: v.clone(), velocity: new THREE.Vector3((Math.random() - 0.5) * 0.1, (Math.random() - 0.5) * 0.1, (Math.random() - 0.5) * 0.1),
          band: Math.floor(Math.random() * 64), phase: Math.random() * TAU, theta: Math.atan2(v.z, v.x), phi: Math.acos(clamp(v.clone().normalize().y, -1, 1)), isExtra: true
        });
      }

      const pGeom = new THREE.BufferGeometry();
      const pPos = new Float32Array(vertexData.length * 3), pCol = new Float32Array(vertexData.length * 3), pSize = new Float32Array(vertexData.length);
      vertexData.forEach((vd, i) => { pPos[i * 3] = vd.current.x; pPos[i * 3 + 1] = vd.current.y; pPos[i * 3 + 2] = vd.current.z; pCol[i * 3] = pCol[i * 3 + 1] = pCol[i * 3 + 2] = 1; pSize[i] = 0.15 + Math.random() * 0.1; });
      pGeom.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
      pGeom.setAttribute('color', new THREE.BufferAttribute(pCol, 3));
      pGeom.setAttribute('size', new THREE.BufferAttribute(pSize, 1));

      const lineGeom = new THREE.BufferGeometry();
      lineGeom.setAttribute('position', new THREE.BufferAttribute(new Float32Array(3000 * 6), 3));
      lineGeom.setAttribute('color', new THREE.BufferAttribute(new Float32Array(3000 * 6), 3));
      lineGeom.setDrawRange(0, 0);
      connectionLines = new THREE.LineSegments(lineGeom, new THREE.LineBasicMaterial({ vertexColors: true, transparent: true, opacity: 0.2, blending: THREE.AdditiveBlending }));
      scene.add(connectionLines);
      connectionLines.visible = config.showConnections;
      // particleSystem removed - replaced by DynamicParticleSystem
    }

    function buildSecondary() {
      if (innerMesh) scene.remove(innerMesh);
      if (outerMesh) scene.remove(outerMesh);
      innerMesh = new THREE.LineSegments(new THREE.WireframeGeometry(new THREE.IcosahedronGeometry(3, 1)), new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.15, blending: THREE.AdditiveBlending }));
      innerMesh.visible = config.showInner; scene.add(innerMesh);
      outerMesh = new THREE.LineSegments(new THREE.WireframeGeometry(new THREE.IcosahedronGeometry(16, 0)), new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.04, blending: THREE.AdditiveBlending }));
      outerMesh.visible = config.showOuter; scene.add(outerMesh);
    }

    function buildWaveformRing() {
      if (waveformRing) scene.remove(waveformRing);
      const positions = new Float32Array(256 * 3);
      for (let i = 0; i < 256; i++) { const ang = (i / 256) * TAU; positions[i * 3] = Math.cos(ang) * 12; positions[i * 3 + 2] = Math.sin(ang) * 12; }
      const geom = new THREE.BufferGeometry();
      geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      waveformRing = new THREE.LineLoop(geom, new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending }));
      waveformRing.rotation.x = Math.PI / 2; waveformRing.visible = config.showWaveform; scene.add(waveformRing);
    }

    function buildFreqBars() {
      freqBars.forEach(b => scene.remove(b)); freqBars = [];
      for (let i = 0; i < 64; i++) {
        const ang = (i / 64) * TAU;
        const bar = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1, 0.3), new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending }));
        bar.position.set(Math.cos(ang) * 16, -15, Math.sin(ang) * 16);
        bar.rotation.y = -ang;
        bar.userData = { index: i, baseY: -15 };
        bar.visible = config.showBars;
        freqBars.push(bar); scene.add(bar);
      }
    }

    function buildRings() {
      rings.forEach(r => scene.remove(r)); rings = [];
      for (let i = 0; i < config.ringCount; i++) {
        const ring = new THREE.Mesh(new THREE.RingGeometry(12 + i * 5, 12.1 + i * 5, 128), new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.03, side: THREE.DoubleSide, blending: THREE.AdditiveBlending }));
        ring.userData = { index: i }; ring.visible = config.showRings; rings.push(ring); scene.add(ring);
      }
    }
    function buildLightRays() {
      lightRays.forEach(r => scene.remove(r)); lightRays = [];
      if (!config.showLightRays) return;
      const rayVert = 'varying float vY; void main() { vY = position.y / 50.0; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }';
      const rayFrag = 'uniform vec3 uColor; uniform float uIntensity; varying float vY; void main() { gl_FragColor = vec4(uColor, (1.0 - vY) * uIntensity * (1.0 - vY)); }';
      for (let i = 0; i < 12; i++) {
        const mat = new THREE.ShaderMaterial({
          uniforms: { uColor: { value: new THREE.Color(1, 1, 1) }, uIntensity: { value: 0.3 } },
          vertexShader: rayVert, fragmentShader: rayFrag,
          transparent: true, depthWrite: false, blending: THREE.AdditiveBlending, side: THREE.DoubleSide
        });
        const ray = new THREE.Mesh(new THREE.ConeGeometry(0.3, 50, 8, 1, true), mat);
        ray.rotation.x = Math.PI; ray.rotation.z = (i / 12) * TAU;
        ray.userData = { baseAngle: ray.rotation.z, speed: 0.1 + Math.random() * 0.2 };
        lightRays.push(ray); scene.add(ray);
      }
    }

    function buildAurora() {
      if (auroraLayer) scene.remove(auroraLayer);
      if (!config.showAurora) return;
      const aVert = 'uniform float uTime, uEnergy; varying vec2 vUv; varying float vDisp; void main() { vUv = uv; vec3 pos = position; float wave = sin(pos.x * 0.15 + uTime * 0.5) * cos(pos.x * 0.08 + uTime * 0.3) + sin(pos.x * 0.22 + uTime * 0.7) * 0.5; pos.z += wave * (3.0 + uEnergy * 5.0); vDisp = wave; gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0); }';
      const aFrag = 'uniform vec3 uColorA, uColorB; uniform float uEnergy; varying vec2 vUv; varying float vDisp; void main() { vec3 col = mix(uColorA, uColorB, vUv.y + vDisp * 0.2); float alpha = (1.0 - vUv.y) * 0.3 * (0.5 + uEnergy) * smoothstep(0.0, 0.3, vUv.y); gl_FragColor = vec4(col, alpha); }';
      auroraLayer = new THREE.Mesh(new THREE.PlaneGeometry(80, 30, 64, 32), new THREE.ShaderMaterial({
        uniforms: { uTime: { value: 0 }, uColorA: { value: new THREE.Color(0x00ff88) }, uColorB: { value: new THREE.Color(0xff00ff) }, uEnergy: { value: 0 } },
        vertexShader: aVert, fragmentShader: aFrag,
        transparent: true, depthWrite: false, blending: THREE.AdditiveBlending, side: THREE.DoubleSide
      }));
      auroraLayer.position.set(0, 25, -30); auroraLayer.rotation.x = -0.3; scene.add(auroraLayer);
    }

    function buildEnergyField() {
      if (energyFieldMesh) scene.remove(energyFieldMesh);
      if (!config.showEnergyField) return;
      const eVert = 'uniform float uTime, uEnergy; varying vec3 vNormal, vPos; void main() { vNormal = normal; vPos = position; vec3 pos = position; float pulse = sin(length(position) * 2.0 - uTime * 3.0) * 0.5 + 0.5; pos += normal * pulse * uEnergy * 2.0; gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0); }';
      const eFrag = 'uniform vec3 uColor; uniform float uTime, uEnergy; varying vec3 vNormal, vPos; void main() { float fresnel = pow(1.0 - abs(dot(normalize(vNormal), vec3(0.0, 0.0, 1.0))), 3.0); float pattern = sin(vPos.x * 5.0 + uTime) * sin(vPos.y * 5.0 + uTime * 1.3) * sin(vPos.z * 5.0 + uTime * 0.7); gl_FragColor = vec4(uColor, fresnel * 0.15 * (0.5 + uEnergy) * (0.5 + pattern * 0.5)); }';
      energyFieldMesh = new THREE.Mesh(new THREE.IcosahedronGeometry(20, 3), new THREE.ShaderMaterial({
        uniforms: { uTime: { value: 0 }, uColor: { value: new THREE.Color(0x888888) }, uEnergy: { value: 0 } },
        vertexShader: eVert, fragmentShader: eFrag,
        transparent: true, depthWrite: false, blending: THREE.AdditiveBlending, side: THREE.DoubleSide, wireframe: true
      }));
      scene.add(energyFieldMesh);
    }

    function buildOrbitals() {
      orbitalRings.forEach(r => scene.remove(r)); orbitalRings = [];
      if (!config.showOrbitals) return;
      for (let i = 0; i < 3; i++) {
        const ring = new THREE.Mesh(new THREE.TorusGeometry(10 + i * 3, 0.05, 8, 128), new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.2, blending: THREE.AdditiveBlending }));
        ring.userData = { index: i, speed: (i + 1) * 0.3 };
        orbitalRings.push(ring); scene.add(ring);
      }
    }

    function buildEnvironment() {
      envObjects.forEach(o => scene.remove(o)); envObjects = [];
      if (floatingParticles) scene.remove(floatingParticles);
      floatingData = [];

      const fpPos = new Float32Array(500 * 3), fpCol = new Float32Array(500 * 3);
      for (let i = 0; i < 500; i++) {
        const theta = Math.random() * TAU, phi = Math.acos(2 * Math.random() - 1), r = 15 + Math.random() * 50;
        fpPos[i * 3] = r * Math.sin(phi) * Math.cos(theta); fpPos[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta); fpPos[i * 3 + 2] = r * Math.cos(phi);
        fpCol[i * 3] = fpCol[i * 3 + 1] = fpCol[i * 3 + 2] = 1;
        floatingData.push({ r, theta, phi, speed: 0.1 + Math.random() * 0.4, band: Math.floor(Math.random() * 64), phase: Math.random() * TAU });
      }
      const fpGeom = new THREE.BufferGeometry();
      fpGeom.setAttribute('position', new THREE.BufferAttribute(fpPos, 3));
      fpGeom.setAttribute('color', new THREE.BufferAttribute(fpCol, 3));
      floatingParticles = new THREE.Points(fpGeom, new THREE.PointsMaterial({ size: 0.1, vertexColors: true, transparent: true, opacity: 0.35, blending: THREE.AdditiveBlending }));
      scene.add(floatingParticles);
      floatingParticles.visible = config.showDeepParticles;

      if (config.environment === 'grid') {
        const grid = new THREE.GridHelper(100, 50, 0x222222, 0x111111); grid.position.y = -20; envObjects.push(grid); scene.add(grid);
      }
      if (config.environment === 'stars') {
        const starPos = new Float32Array(3000 * 3);
        for (let i = 0; i < 3000; i++) { starPos[i * 3] = (Math.random() - 0.5) * 250; starPos[i * 3 + 1] = (Math.random() - 0.5) * 250; starPos[i * 3 + 2] = (Math.random() - 0.5) * 250; }
        const sGeom = new THREE.BufferGeometry();
        sGeom.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        const stars = new THREE.Points(sGeom, new THREE.PointsMaterial({ size: 0.18, color: 0xffffff, transparent: true, opacity: 0.7 }));
        envObjects.push(stars); scene.add(stars);
      }
      if (config.environment === 'nebula') {
        for (let i = 0; i < 6; i++) {
          const neb = new THREE.Mesh(new THREE.SphereGeometry(35 + i * 12, 20, 20), new THREE.MeshBasicMaterial({ color: new THREE.Color().setHSL(0.58 + i * 0.08, 0.6, 0.12), transparent: true, opacity: 0.04, side: THREE.BackSide, blending: THREE.AdditiveBlending }));
          neb.userData = { rotSpeed: 0.001 * (i + 1) }; envObjects.push(neb); scene.add(neb);
        }
      }
    }

    function buildShockwaves() {
      shockwaves.forEach(s => scene.remove(s.mesh)); shockwaves.length = 0;
      if (!config.showShockwaves) return;

      // Billboarded rings (always face the camera) - more readable from any angle
      const shockVert = `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
        `;
      const shockFrag = `
        uniform vec3 uColor;
        uniform float uOpacity;
        varying vec2 vUv;
        void main() {
          // Soft radial ring falloff
          vec2 p = vUv - 0.5;
          float r = length(p) * 2.0;
          float ring = exp(-pow(abs(r - 1.0) * 3.5, 2.0));
          float fade = smoothstep(1.6, 0.0, r);
          float a = ring * fade * uOpacity;
          if (a < 0.01) discard;
          gl_FragColor = vec4(uColor, a);
        }
        `;

      const geom = new THREE.RingGeometry(0.90, 1.28, 192, 1);
      for (let i = 0; i < 12; i++) {
        const mat = new THREE.ShaderMaterial({
          uniforms: { uColor: { value: new THREE.Color(1, 1, 1) }, uOpacity: { value: 0 } },
          vertexShader: shockVert,
          fragmentShader: shockFrag,
          transparent: true,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
          side: THREE.DoubleSide
        });
        const mesh = new THREE.Mesh(geom, mat);
        mesh.visible = config.showShockwaves;
        scene.add(mesh);
        shockwaves.push({ mesh, life: 0, active: false, strength: 1.0 });
      }
    }

    function spawnShockwave(color, strength = 1.0) {
      if (!config.showShockwaves || shockwaves.length === 0) return;
      const s = shockwaves.find(x => !x.active) || shockwaves[0];
      s.active = true;
      s.life = 1.0;
      s.strength = clamp(strength, 0.15, 1.25);
      s.mesh.scale.setScalar(1.0);
      s.mesh.position.set(0, 0, 0);
      s.mesh.material.uniforms.uOpacity.value = config.shockwaveIntensity * s.strength;
      s.mesh.material.uniforms.uColor.value.copy(color);
    }

    // --------------------------------------------------------------------
    // Post-processing pipeline
    // --------------------------------------------------------------------
    renderer.autoClear = false;

    const composer = new EffectComposer(renderer);

    // Draw shader background first
    const bgPass = new RenderPass(bgScene, bgCam);
    bgPass.clear = true;
    composer.addPass(bgPass);

    // Then draw main 3D scene on top without clearing
    const mainPass = new RenderPass(scene, camera);
    mainPass.clear = false;
    composer.addPass(mainPass);

    // Trails
    const afterimagePass = new AfterimagePass();
    afterimagePass.enabled = config.trailMode !== 'none';
    composer.addPass(afterimagePass);

    // Bloom with improved threshold for more selective glow
    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      config.bloomStrength,
      config.bloomRadius,
      0.12  // Lower threshold for more bloom on bright areas
    );
    bloomPass.threshold = 0.12;
    composer.addPass(bloomPass);

    // Screen FX shader (vignette / grain / aberration / scanlines / kaleido / glitch / film)
    const screenVert = /* glsl */`
      varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = vec4(position.xy, 0.0, 1.0);
        }
        `;

    const screenFrag = /* glsl */`
      precision highp float;

      varying vec2 vUv;
      uniform sampler2D tDiffuse;
      uniform float uTime;
      uniform vec2 uResolution;

      uniform float uVignette;
      uniform float uGrain;
      uniform float uAberration;
      uniform float uHigh;
      uniform float uAnamorphic;
      uniform float uScanlines;

      uniform float uKaleidoscope;
      uniform float uKaleidoscopeSegments;

      uniform float uFilmLook;   
      uniform float uNegative;   
      uniform float uBeatPulse;  
      uniform float uGlitch;

      // Grading Uniforms
      uniform vec3 uLift;
      uniform vec3 uGamma;
      uniform vec3 uGain;
      uniform float uGradeSat;
      uniform float uGradeVibrance;
      uniform float uHueRotate;

      // Filmic Color Grading Uniforms
      uniform sampler2D uCurvesR;
      uniform sampler2D uCurvesG;
      uniform sampler2D uCurvesB;
      uniform vec3 uSplitToneShadows;
      uniform vec3 uSplitToneHighlights;
      uniform float uSplitToneBalance;
      uniform float uColorTemp;
      uniform float uTint;
      uniform float uFilmCurve;
      uniform mat3 uChannelMixer;

      // LUT Uniforms
      uniform sampler3D uLUT;
      uniform float uLutEnabled;
      uniform float uLutIntensity;

      float sat(float x){ return clamp(x, 0.0, 1.0); }

      float rand(vec2 p) {
          p = fract(p * vec2(123.34, 456.21));
          p += dot(p, p + 45.32);
          return fract(p.x * p.y);
        }

      vec3 toLuma(vec3 c){ float l = dot(c, vec3(0.2126, 0.7152, 0.0722)); return vec3(l); }

      vec3 adjustSaturation(vec3 c, float s){
        float l = dot(c, vec3(0.2126, 0.7152, 0.0722));
          return mix(vec3(l), c, s);
        }

      // RGB to HSV conversion
      vec3 rgb2hsv(vec3 c) {
        vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
        vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
        vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
        float d = q.x - min(q.w, q.y);
        float e = 1.0e-10;
        return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
      }

      // HSV to RGB conversion
      vec3 hsv2rgb(vec3 c) {
        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
      }

      // RGB to HSL conversion
      vec3 rgb2hsl(vec3 c) {
        float maxVal = max(c.r, max(c.g, c.b));
        float minVal = min(c.r, min(c.g, c.b));
        float delta = maxVal - minVal;
        float l = (maxVal + minVal) * 0.5;
        float h = 0.0;
        float s = 0.0;
        if (delta > 0.0) {
          s = l > 0.5 ? delta / (2.0 - maxVal - minVal) : delta / (maxVal + minVal);
          if (maxVal == c.r) {
            h = mod((c.g - c.b) / delta + (c.g < c.b ? 6.0 : 0.0), 6.0) / 6.0;
          } else if (maxVal == c.g) {
            h = ((c.b - c.r) / delta + 2.0) / 6.0;
          } else {
            h = ((c.r - c.g) / delta + 4.0) / 6.0;
          }
        }
        return vec3(h, s, l);
      }

      float hue2rgb(float p, float q, float t) {
        if (t < 0.0) t += 1.0;
        if (t > 1.0) t -= 1.0;
        if (t < 1.0 / 6.0) return p + (q - p) * 6.0 * t;
        if (t < 1.0 / 2.0) return q;
        if (t < 2.0 / 3.0) return p + (q - p) * (2.0 / 3.0 - t) * 6.0;
        return p;
      }

      // HSL to RGB conversion
      vec3 hsl2rgb(vec3 c) {
        vec3 rgb = vec3(c.z);
        if (c.y > 0.0) {
          float q = c.z < 0.5 ? c.z * (1.0 + c.y) : c.z + c.y - c.z * c.y;
          float p = 2.0 * c.z - q;
          rgb.r = hue2rgb(p, q, c.x + 1.0 / 3.0);
          rgb.g = hue2rgb(p, q, c.x);
          rgb.b = hue2rgb(p, q, c.x - 1.0 / 3.0);
        }
        return rgb;
      }

      // Improved Vibrance - HSV-based, protects saturated colors
      vec3 applyVibrance(vec3 c, float v) {
        vec3 hsv = rgb2hsv(c);
        float saturation = hsv.y;
        float relativeLum = dot(c, vec3(0.2126, 0.7152, 0.0722));
        float saturationBoost = (1.0 - saturation) * v;
        hsv.y = clamp(saturation + saturationBoost, 0.0, 1.0);
        return hsv2rgb(hsv);
      }

      // RGB Curves - Sample from 64x1 DataTexture
      float applyCurve(float val, sampler2D curveTex) {
        float u = clamp(val, 0.0, 1.0);
        return texture2D(curveTex, vec2(u, 0.5)).r;
      }

      // Film Response Curves
      vec3 applyFilmCurve(vec3 col, float curveType) {
        if (curveType < 0.5) return col; // None
        
        vec3 result = col;
        if (curveType >= 0.5 && curveType < 1.5) {
          // Kodak Vision3 500T
          float toe = 0.18;
          float shoulder = 0.9;
          result.r = col.r < toe ? mix(0.0, toe, smoothstep(0.0, toe, col.r)) : 
                   (col.r < shoulder ? mix(toe, shoulder, (col.r - toe) / (shoulder - toe)) :
                   mix(shoulder, 1.0, 1.0 - exp(-(col.r - shoulder) * 5.0)));
          result.g = col.g < toe ? mix(0.0, toe, smoothstep(0.0, toe, col.g)) : 
                   (col.g < shoulder ? mix(toe, shoulder, (col.g - toe) / (shoulder - toe)) :
                   mix(shoulder, 1.0, 1.0 - exp(-(col.g - shoulder) * 5.0)));
          result.b = col.b < toe ? mix(0.0, toe, smoothstep(0.0, toe, col.b)) : 
                   (col.b < shoulder ? mix(toe, shoulder, (col.b - toe) / (shoulder - toe)) :
                   mix(shoulder, 1.0, 1.0 - exp(-(col.b - shoulder) * 5.0)));
        } else if (curveType >= 1.5 && curveType < 2.5) {
          // Fuji Eterna 8543
          float toe = 0.15;
          float shoulder = 0.92;
          result.r = col.r < toe ? mix(0.0, toe, pow(col.r / toe, 1.2)) : 
                   (col.r < shoulder ? mix(toe, shoulder, (col.r - toe) / (shoulder - toe)) :
                   mix(shoulder, 1.0, 1.0 - exp(-(col.r - shoulder) * 4.5)));
          result.g = col.g < toe ? mix(0.0, toe, pow(col.g / toe, 1.2)) : 
                   (col.g < shoulder ? mix(toe, shoulder, (col.g - toe) / (shoulder - toe)) :
                   mix(shoulder, 1.0, 1.0 - exp(-(col.g - shoulder) * 4.5)));
          result.b = col.b < toe ? mix(0.0, toe, pow(col.b / toe, 1.2)) : 
                   (col.b < shoulder ? mix(toe, shoulder, (col.b - toe) / (shoulder - toe)) :
                   mix(shoulder, 1.0, 1.0 - exp(-(col.b - shoulder) * 4.5)));
        }
        return result;
      }

      // Color Temperature - Kelvin to RGB using Planckian locus approximation
      vec3 applyColorTemperature(vec3 col, float temp, float tint) {
        // Normalize temp from 0-1 to 2000-10000K
        float T = temp * 8000.0 + 2000.0;
        
        // Planckian locus approximation
        float T2 = T * T;
        float T3 = T2 * T;
        float invT = 1.0 / T;
        float invT2 = invT * invT;
        
        // Calculate chromaticity (simplified approximation)
        float x, y;
        if (T < 4000.0) {
          x = -0.2661239 * 1e9 * invT3 + 0.2343580 * 1e6 * invT2 + 0.8776956 * 1e3 * invT + 0.179910;
        } else {
          x = -3.0258469 * 1e9 * invT3 + 2.1070379 * 1e6 * invT2 + 0.2226347 * 1e3 * invT + 0.240390;
        }
        y = -1.1063814 * x * x * x - 1.34811020 * x * x + 2.18555832 * x - 0.20219683;
        
        // Convert to RGB using D65 white point reference
        float z = 1.0 - x - y;
        float Y = 1.0;
        float X = (Y / y) * x;
        float Z = (Y / y) * z;
        
        // D65 reference white
        float Xr = 0.95047;
        float Yr = 1.00000;
        float Zr = 1.08883;
        
        // Normalize
        X /= Xr;
        Z /= Zr;
        
        // Apply temperature shift
        vec3 tempShift = vec3(
          X * 1.4628067 - Y * 0.1840623 - Z * 0.2743606,
          -X * 0.5217933 + Y * 1.4472381 + Z * 0.0677227,
          X * 0.0349342 - Y * 0.0968930 + Z * 1.2884099
        );
        
        // Apply tint (magenta/green shift)
        vec3 tintShift = vec3(1.0 + tint * 0.1, 1.0 - tint * 0.05, 1.0 + tint * 0.1);
        
        return col * tempShift * tintShift;
      }

      // Split Toning with HSL blending
      vec3 applySplitToning(vec3 col, vec3 shadowTint, vec3 highlightTint, float balance) {
        float lum = dot(col, vec3(0.2126, 0.7152, 0.0722));
        float shadowMask = smoothstep(0.25, 0.0, lum);
        float highlightMask = smoothstep(0.75, 1.0, lum);
        
        // Convert tints to HSL
        vec3 shadowHSL = rgb2hsl(shadowTint);
        vec3 highlightHSL = rgb2hsl(highlightTint);
        vec3 colHSL = rgb2hsl(col);
        
        // Blend hues and saturations, preserve luminance
        float balanceFactor = (balance + 1.0) * 0.5; // -1 to 1 -> 0 to 1
        float combinedMask = mix(shadowMask, highlightMask, balanceFactor);
        
        colHSL.x = mix(colHSL.x, mix(shadowHSL.x, highlightHSL.x, balanceFactor), combinedMask * 0.3);
        colHSL.y = mix(colHSL.y, mix(shadowHSL.y, highlightHSL.y, balanceFactor), combinedMask * 0.4);
        
        return hsl2rgb(colHSL);
      }

      vec3 hueRotate(vec3 c, float a) {
          vec3 k = vec3(0.57735);
          float cosA = cos(a);
          return c * cosA + cross(k, c) * sin(a) + k * dot(k, c) * (1.1 - cosA);
        }

        void main() {
        vec2 uv = vUv;

          if (uKaleidoscope > 0.5) {
          vec2 p = uv - 0.5;
          float r = length(p);
          float a = atan(p.y, p.x);
          float n = max(1.0, uKaleidoscopeSegments);
          float sector = 6.28318530718 / n;
            a = mod(a + 6.28318530718, sector);
            a = abs(a - sector * 0.5);
            p = vec2(cos(a), sin(a)) * r;
            uv = p + 0.5;
          }

          if (uGlitch > 0.001) {
          float band = floor(uv.y * 24.0);
          float n = rand(vec2(band, floor(uTime * 6.0)));
            uv.x += (n - 0.5) * 0.08 * uGlitch;
            uv.y += (rand(vec2(band * 3.7, uTime * 0.4)) - 0.5) * 0.03 * uGlitch;
          }

        vec2 dir = uv - 0.5;
        float d = length(dir) + 1e-6;
          dir /= d;
        vec2 off = dir * uAberration * (0.002 + 0.004 * sat(uHigh));

        vec3 col;
          col.r = texture2D(tDiffuse, uv + off).r;
          col.g = texture2D(tDiffuse, uv).g;
          col.b = texture2D(tDiffuse, uv - off).b;

          if (uAnamorphic > 0.001) {
          vec2 o = vec2(off.x * 6.0, 0.0);
          vec3 smear = 0.5 * (texture2D(tDiffuse, uv + o).rgb + texture2D(tDiffuse, uv - o).rgb);
            col = mix(col, smear, uAnamorphic * 0.35);
          }

          // Filmic Color Grading Pipeline
          // 1. Film Response Curves (log-to-lin transform with toe/shoulder)
          col = applyFilmCurve(col, uFilmCurve);
          
          // 2. RGB Curves (cubic Bezier evaluation per channel)
          col.r = applyCurve(col.r, uCurvesR);
          col.g = applyCurve(col.g, uCurvesG);
          col.b = applyCurve(col.b, uCurvesB);
          
          // 3. Channel Mixer (RGB remix)
          col = uChannelMixer * col;
          
          // 4. Color Temperature (Kelvin + Magenta/Green tint)
          // uColorTemp is already in Kelvin (2000-10000), normalize to 0-1
          float tempNorm = clamp((uColorTemp - 2000.0) / 8000.0, 0.0, 1.0);
          col = applyColorTemperature(col, tempNorm, uTint);
          
          // 5. Split Toning (shadows/highlights with HSL blending)
          col = applySplitToning(col, uSplitToneShadows, uSplitToneHighlights, uSplitToneBalance);
          
          // 6. Vibrance (HSV-based, protects saturated colors)
          col = applyVibrance(col, uGradeVibrance);
          
          // 7. Saturation
          col = adjustSaturation(col, uGradeSat);
          
          if (uHueRotate > 0.01) col = hueRotate(col, uHueRotate * 6.2831);

          // Apply LUT
          if (uLutEnabled > 0.5) {
            vec3 lutCol = texture(uLUT, col).rgb;
            col = mix(col, lutCol, uLutIntensity);
          }

          if (uFilmLook > 0.5 && uFilmLook < 1.5) {
            col *= vec3(1.03, 1.00, 0.98);
          } else if (uFilmLook >= 1.5 && uFilmLook < 2.5) {
            col = mix(col, col * vec3(1.06, 1.02, 0.92) + vec3(0.02, 0.015, 0.0), 0.55);
          }

        float vig = smoothstep(0.86, 0.28, distance(vUv, vec2(0.5)));
          col *= mix(1.0, vig, sat(uVignette));

          if (uScanlines > 0.001) {
          float s = 0.5 + 0.5 * sin(vUv.y * uResolution.y * 3.14159265);
            col *= 1.0 - uScanlines * 0.09 * s;
          }

        float g = (rand(vUv * uResolution.xy + fract(uTime) * 1000.0) - 0.5);
          col += g * (0.06 * uGrain) * (0.35 + 0.65 * sat(uHigh));
          col += vec3(1.0) * uBeatPulse * 0.08;

          if (uNegative > 0.5) col = mix(col, vec3(1.0) - col, 0.75);

          gl_FragColor = vec4(col, 1.0);
        }
        `;

    const screenFXPass = new ShaderPass({
      uniforms: {
        tDiffuse: { value: null }, uTime: { value: 0 }, uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
        uVignette: { value: config.vignette }, uGrain: { value: config.grain }, uAberration: { value: config.aberration },
        uHigh: { value: 0 }, uAnamorphic: { value: config.anamorphic }, uScanlines: { value: config.scanlines },
        uKaleidoscope: { value: 0 }, uKaleidoscopeSegments: { value: 6 }, uFilmLook: { value: 0 }, uBeatPulse: { value: 0 }, uGlitch: { value: 0 },
        uNegative: { value: 0 },
        // Color Grade LGG
        uLift: { value: new THREE.Color(config.gradeLift) },
        uGamma: { value: new THREE.Color(config.gradeGamma) },
        uGain: { value: new THREE.Color(config.gradeGain) },
        uGradeSat: { value: config.gradeSat },
        uGradeVibrance: { value: config.gradeVibrance },
        uHueRotate: { value: config.hueRotateGrade / 360 }
      },
      vertexShader: screenVert, fragmentShader: screenFrag
    });

    const lutUniforms = {
      uLUT: { value: null },
      uLutEnabled: { value: 0.0 },
      uLutIntensity: { value: 0.5 }
    };
    Object.assign(screenFXPass.uniforms, lutUniforms);

    // Initialize filmic color grading uniforms
    const filmicUniforms = {
      uCurvesR: { value: generateCurveTexture(config.curveRShadows, config.curveRMids, config.curveRHighlights, config.curveRWhites) },
      uCurvesG: { value: generateCurveTexture(config.curveGShadows, config.curveGMids, config.curveGHighlights, config.curveGWhites) },
      uCurvesB: { value: generateCurveTexture(config.curveBShadows, config.curveBMids, config.curveBHighlights, config.curveBWhites) },
      uSplitToneShadows: { value: new THREE.Color(config.splitToneShadows) },
      uSplitToneHighlights: { value: new THREE.Color(config.splitToneHighlights) },
      uSplitToneBalance: { value: config.splitToneBalance },
      uColorTemp: { value: config.colorTemp },
      uTint: { value: config.tint },
      uFilmCurve: { value: config.filmCurve },
      uChannelMixer: { value: new THREE.Matrix3().set(
        config.channelMixerRR, config.channelMixerRG, config.channelMixerRB,
        config.channelMixerGR, config.channelMixerGG, config.channelMixerGB,
        config.channelMixerBR, config.channelMixerBG, config.channelMixerBB
      )}
    };
    Object.assign(screenFXPass.uniforms, filmicUniforms);

    // Update curve texture when control points change
    function updateCurveTexture(channel) {
      const shadows = config[`curve${channel}Shadows`];
      const mids = config[`curve${channel}Mids`];
      const highlights = config[`curve${channel}Highlights`];
      const whites = config[`curve${channel}Whites`];
      const texture = generateCurveTexture(shadows, mids, highlights, whites);
      if (screenFXPass.uniforms[`uCurves${channel}`]) {
        screenFXPass.uniforms[`uCurves${channel}`].value = texture;
      }
      drawCurve(channel);
    }

    // Draw curve on canvas
    function drawCurve(channel) {
      const canvas = document.getElementById(`curve${channel}-canvas`);
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      const w = canvas.width;
      const h = canvas.height;
      
      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
      ctx.fillRect(0, 0, w, h);
      
      // Draw grid
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
      ctx.lineWidth = 1;
      for (let i = 0; i <= 4; i++) {
        const x = (i / 4) * w;
        const y = (i / 4) * h;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, h);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
      }
      
      // Draw curve
      const shadows = config[`curve${channel}Shadows`];
      const mids = config[`curve${channel}Mids`];
      const highlights = config[`curve${channel}Highlights`];
      const whites = config[`curve${channel}Whites`];
      
      const color = channel === 'R' ? '#ff3333' : channel === 'G' ? '#33ff33' : '#3333ff';
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      
      for (let i = 0; i < w; i++) {
        const t = i / (w - 1);
        let y;
        if (t < 0.33) {
          const localT = t / 0.33;
          y = shadows + (mids - shadows) * (localT * localT * (3 - 2 * localT));
        } else if (t < 0.66) {
          const localT = (t - 0.33) / 0.33;
          y = mids + (highlights - mids) * (localT * localT * (3 - 2 * localT));
        } else {
          const localT = (t - 0.66) / 0.34;
          y = highlights + (whites - highlights) * (localT * localT * (3 - 2 * localT));
        }
        const py = h - (y * h);
        if (i === 0) ctx.moveTo(i, py);
        else ctx.lineTo(i, py);
      }
      ctx.stroke();
      
      // Draw control points
      const points = [
        { x: 0, y: shadows },
        { x: 0.33 * w, y: mids },
        { x: 0.66 * w, y: highlights },
        { x: w, y: whites }
      ];
      ctx.fillStyle = color;
      points.forEach(p => {
        ctx.beginPath();
        ctx.arc(p.x, h - (p.y * h), 4, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    // Reset curve to default
    function resetCurve(channel) {
      config[`curve${channel}Shadows`] = 0.0;
      config[`curve${channel}Mids`] = 0.33;
      config[`curve${channel}Highlights`] = 0.66;
      config[`curve${channel}Whites`] = 1.0;
      updateCurveTexture(channel);
      // Update UI sliders
      document.getElementById(`curve${channel}Shadows`).value = 0.0;
      document.getElementById(`curve${channel}Mids`).value = 0.33;
      document.getElementById(`curve${channel}Highlights`).value = 0.66;
      document.getElementById(`curve${channel}Whites`).value = 1.0;
    }

    // Update channel mixer matrix
    function updateChannelMixer() {
      if (!screenFXPass.uniforms.uChannelMixer) return;
      const m = new THREE.Matrix3().set(
        config.channelMixerRR, config.channelMixerRG, config.channelMixerRB,
        config.channelMixerGR, config.channelMixerGG, config.channelMixerGB,
        config.channelMixerBR, config.channelMixerBG, config.channelMixerBB
      );
      screenFXPass.uniforms.uChannelMixer.value = m;
    }

    // Histogram visualization
    let histogramData = { r: new Array(256).fill(0), g: new Array(256).fill(0), b: new Array(256).fill(0) };
    let histogramFrameCount = 0;

    function updateHistogram() {
      const canvas = document.getElementById('histogram-canvas');
      if (!canvas) return;
      
      // Sample every 4th frame for performance
      histogramFrameCount++;
      if (histogramFrameCount % 4 !== 0) {
        drawHistogram(canvas);
        return;
      }
      
      const ctx = canvas.getContext('2d');
      const w = canvas.width = canvas.clientWidth || 400;
      const h = canvas.height = canvas.clientHeight || 120;
      
      // Reset histogram
      histogramData.r.fill(0);
      histogramData.g.fill(0);
      histogramData.b.fill(0);
      
      // Sample from render target (lower resolution for performance)
      if (composer && composer.readRenderTargetPixels) {
        try {
          const sampleSize = 4; // Sample every 4th pixel
          const pixels = new Uint8Array(w * h * 4);
          // Note: readRenderTargetPixels requires render target, we'll use a workaround
          // For now, we'll draw a placeholder and implement full sampling later
        } catch (e) {
          // Fallback: draw placeholder
        }
      }
      
      drawHistogram(canvas);
    }

    function drawHistogram(canvas) {
      const ctx = canvas.getContext('2d');
      const w = canvas.width;
      const h = canvas.height;
      
      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.fillRect(0, 0, w, h);
      
      // Draw RGB parade (3 vertical bars)
      const barWidth = w / 3;
      const maxHeight = h - 10;
      
      // Red channel
      ctx.fillStyle = 'rgba(255, 0, 0, 0.6)';
      for (let i = 0; i < 256; i++) {
        const x = (i / 256) * barWidth;
        const height = (histogramData.r[i] / Math.max(...histogramData.r, 1)) * maxHeight;
        ctx.fillRect(x, h - height, barWidth / 256, height);
      }
      
      // Green channel
      ctx.fillStyle = 'rgba(0, 255, 0, 0.6)';
      for (let i = 0; i < 256; i++) {
        const x = barWidth + (i / 256) * barWidth;
        const height = (histogramData.g[i] / Math.max(...histogramData.g, 1)) * maxHeight;
        ctx.fillRect(x, h - height, barWidth / 256, height);
      }
      
      // Blue channel
      ctx.fillStyle = 'rgba(0, 0, 255, 0.6)';
      for (let i = 0; i < 256; i++) {
        const x = barWidth * 2 + (i / 256) * barWidth;
        const height = (histogramData.b[i] / Math.max(...histogramData.b, 1)) * maxHeight;
        ctx.fillRect(x, h - height, barWidth / 256, height);
      }
      
      // Draw separators
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(barWidth, 0);
      ctx.lineTo(barWidth, h);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(barWidth * 2, 0);
      ctx.lineTo(barWidth * 2, h);
      ctx.stroke();
    }

    // Initialize curve canvases
    ['R', 'G', 'B'].forEach(ch => {
      setTimeout(() => drawCurve(ch), 100);
    });

    function parseCubeLUT(data) {
      const lines = data.split('\n');
      let size = 0;
      const pixels = [];
      for (let line of lines) {
        line = line.trim();
        if (!line || line.startsWith('#')) continue;
        if (line.startsWith('LUT_3D_SIZE')) {
          size = parseInt(line.split(' ')[1]);
          continue;
        }
        const parts = line.split(/\s+/).map(parseFloat);
        if (parts.length === 3 && !isNaN(parts[0])) {
          pixels.push(parts[0], parts[1], parts[2], 1.0);
        }
      }
      if (size === 0) return null;
      const texture = new THREE.Data3DTexture(new Float32Array(pixels), size, size, size);
      texture.format = THREE.RGBAFormat; texture.type = THREE.FloatType;
      texture.minFilter = texture.magFilter = THREE.LinearFilter;
      texture.unpackAlignment = 1; texture.needsUpdate = true;
      return texture;
    }

    // Generate 64x1 curve texture from 4 control points using cubic Bezier
    function generateCurveTexture(shadows, mids, highlights, whites) {
      const size = 64;
      const data = new Float32Array(size * 4);
      
      // Control points: shadows (0.0), mids (0.33), highlights (0.66), whites (1.0)
      const p0 = { x: 0.0, y: shadows };
      const p1 = { x: 0.33, y: mids };
      const p2 = { x: 0.66, y: highlights };
      const p3 = { x: 1.0, y: whites };
      
      // Generate curve using cubic Bezier interpolation
      for (let i = 0; i < size; i++) {
        const t = i / (size - 1);
        // Use smoothstep for smoother interpolation between control points
        let y;
        if (t < 0.33) {
          const localT = t / 0.33;
          y = mix(shadows, mids, smoothstep(0.0, 1.0, localT));
        } else if (t < 0.66) {
          const localT = (t - 0.33) / 0.33;
          y = mix(mids, highlights, smoothstep(0.0, 1.0, localT));
        } else {
          const localT = (t - 0.66) / 0.34;
          y = mix(highlights, whites, smoothstep(0.0, 1.0, localT));
        }
        
        data[i * 4] = clamp(y, 0.0, 1.0);
        data[i * 4 + 1] = clamp(y, 0.0, 1.0);
        data[i * 4 + 2] = clamp(y, 0.0, 1.0);
        data[i * 4 + 3] = 1.0;
      }
      
      const texture = new THREE.DataTexture(data, size, 1);
      texture.format = THREE.RGBAFormat;
      texture.type = THREE.FloatType;
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.wrapS = THREE.ClampToEdgeWrapping;
      texture.wrapT = THREE.ClampToEdgeWrapping;
      texture.needsUpdate = true;
      return texture;
    }

    function smoothstep(edge0, edge1, x) {
      const t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
      return t * t * (3.0 - 2.0 * t);
    }

    function mix(x, y, a) {
      return x * (1.0 - a) + y * a;
    }

    function clamp(x, min, max) {
      return Math.max(min, Math.min(max, x));
    }

    function buildHDRIMap() {
      const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 256;
      const ctx = canvas.getContext('2d');
      const grad = ctx.createRadialGradient(256, 128, 10, 256, 128, 256);
      grad.addColorStop(0, '#ffffff'); grad.addColorStop(0.2, '#88ccff'); grad.addColorStop(1, '#000000');
      ctx.fillStyle = grad; ctx.fillRect(0, 0, 512, 256);
      const tex = new THREE.CanvasTexture(canvas);
      tex.mapping = THREE.EquirectangularReflectionMapping;
      return tex;
    }
    const hdriMap = buildHDRIMap();
    scene.environment = config.showHDRI ? hdriMap : null;

    const bokehPass = new BokehPass(scene, camera, {
      focus: config.dofFocusDistance,
      aperture: config.dofAperture,
      maxblur: config.dofBokehScale,
      width: window.innerWidth,
      height: window.innerHeight
    });
    bokehPass.enabled = config.dofEnabled;
    composer.addPass(bokehPass);

    composer.addPass(screenFXPass);

    function updateTrailMode() {
      switch (config.trailMode) {
        case 'none': afterimagePass.enabled = false; break;
        case 'light': afterimagePass.enabled = true; afterimagePass.uniforms.damp.value = 0.82; break;
        case 'medium': afterimagePass.enabled = true; afterimagePass.uniforms.damp.value = 0.91; break;
        case 'heavy': afterimagePass.enabled = true; afterimagePass.uniforms.damp.value = 0.96; break;
        case 'smear': afterimagePass.enabled = true; afterimagePass.uniforms.damp.value = 0.985; break;
      }
    }
    updateTrailMode();

    // Audio Setup - Enhanced with higher resolution FFT
    const audioEl = document.getElementById('audio');
    let audioCtx, analyser, sourceNode, gainNode, mediaDest, freqData, timeData, playing = false;
    // Optional: secondary analyser for stereo separation (future enhancement)
    let analyserL, analyserR;

    function initAudio() {
      if (audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      sourceNode = audioCtx.createMediaElementSource(audioEl);
      analyser = audioCtx.createAnalyser();

      // FFT size and resolution
      analyser.fftSize = parseInt(config.analyzerFftSize || 1024);
      // Zero smoothing - we do our own adaptive smoothing
      analyser.smoothingTimeConstant = 0.0;
      // Lower min/max dB for better dynamic range capture
      analyser.minDecibels = -90;
      analyser.maxDecibels = -10;

      // Stereo split for enhanced waveform
      const splitter = audioCtx.createChannelSplitter(2);
      analyserL = audioCtx.createAnalyser();
      analyserR = audioCtx.createAnalyser();
      analyserL.fftSize = analyserR.fftSize = analyser.fftSize;

      gainNode = audioCtx.createGain();
      gainNode.gain.value = config.volume;

      // High-pass filter to remove DC offset and very low rumble
      const highpass = audioCtx.createBiquadFilter();
      highpass.type = 'highpass';
      highpass.frequency.value = 20;
      highpass.Q.value = 0.7;

      // Gentle compression for more consistent levels
      const compressor = audioCtx.createDynamicsCompressor();
      compressor.threshold.value = -24;
      compressor.knee.value = 30;
      compressor.ratio.value = 3;
      compressor.attack.value = 0.003;
      compressor.release.value = 0.25;

      mediaDest = audioCtx.createMediaStreamDestination();

      // Signal chain: source -> highpass -> compressor -> split -> analysers -> combine -> gain -> output
      sourceNode.connect(highpass);
      highpass.connect(compressor);
      compressor.connect(splitter);

      splitter.connect(analyserL, 0);
      splitter.connect(analyserR, 1);

      // Mono analyser for main visualization
      compressor.connect(analyser);

      analyser.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      gainNode.connect(mediaDest);

      freqData = new Uint8Array(analyser.frequencyBinCount);
      timeData = new Uint8Array(analyser.fftSize);
      audio.setFFTInfo(analyser.fftSize, analyser.sampleRate);

      if (window.analysisManager) window.analysisManager.onAudioInit();
    }

    // Color helpers
    const tmpHSL1 = { h: 0, s: 0, l: 0 }, tmpHSL2 = { h: 0, s: 0, l: 0 };
    const palette = { hOffset: 0, hOffsetTarget: 0, globalHueShift: 0 };

    function applyColorTheme() {
      const theme = colorThemes[config.colorTheme];
      if (theme) {
        config.colorPrimary = theme.primary; config.colorSecondary = theme.secondary; config.colorBg = theme.bg;
        document.getElementById('colorPrimary').value = theme.primary;
        document.getElementById('colorSecondary').value = theme.secondary;
        document.getElementById('colorBg').value = theme.bg;
      }
      scene.fog.color = new THREE.Color(config.colorBg);
      bgUniforms.uBgColor.value.set(config.colorBg);
      bgUniforms.uAccentA.value.set(config.colorPrimary);
      bgUniforms.uAccentB.value.set(config.colorSecondary);
    }

    function getHarmonizedColor(energy, bandMix01) {
      const c1 = new THREE.Color(config.colorPrimary), c2 = new THREE.Color(config.colorSecondary);
      c1.getHSL(tmpHSL1); c2.getHSL(tmpHSL2);

      // More dynamic mix amount with non-linear response
      const rawMix = bandMix01 * config.colorReactivity + energy * config.colorReactivity * 0.4;
      const mixAmt = clamp(easeInOutSine(rawMix), 0, 1);

      let h = lerp(tmpHSL1.h, tmpHSL2.h, mixAmt) + palette.hOffset + palette.globalHueShift;

      // Enhanced color cycling with multiple harmonics
      if (config.colorCycle) {
        h += 0.018 * Math.sin(music.phase * 0.06);
        h += 0.008 * Math.sin(music.phase * 0.15 + Math.PI / 3);
      }

      // Synesthesia: map musical notes to colors with smoother transitions
      if (config.synesthesia && Number.isFinite(audio.rootNote)) {
        // Use chroma intensity for smoother note-color mapping
        const chromaMax = Math.max(...audio.chroma);
        if (chromaMax > 0.1) {
          const noteHue = audio.rootNote / 12;
          h = lerp(h, noteHue, 0.35 * (chromaMax / (chromaMax + 0.5)));
        }
      }
      h = fract(h);

      // Enhanced saturation based on audio dynamics
      const baseSat = lerp(tmpHSL1.s, tmpHSL2.s, mixAmt);
      const satBoost = audio.transientSharpness * 0.15 + audio.smoothHighMid * 0.1;
      const s = clamp(baseSat * (0.75 + 0.50 * audio.smoothHigh + satBoost), 0.1, 0.98);

      // Enhanced lightness with more dynamic range
      const baseLum = lerp(tmpHSL1.l, tmpHSL2.l, mixAmt);
      const lumBoost = audio.onsetKick * 0.15 + audio.spectralFlux * 0.08;
      const l = clamp(baseLum * (0.50 + 0.70 * energy + lumBoost), 0.08, 0.88);

      return new THREE.Color().setHSL(h, s, l);
    }

    function noise3D(x, y, z) { return (fract(Math.sin(x * 12.9898 + y * 78.233 + z * 45.164) * 43758.5453) * 2 - 1); }
    function foldTheta(theta, n) { const sector = TAU / Math.max(1, n); let a = (theta + Math.PI) % sector; if (a < 0) a += sector; return a * n; }

    // === SHARING & CAPTURE SYSTEM ===

    async function takeHighResSnapshot() {
      const multMap = { '1x': 1, '2x': 2, '4x': 4 };
      const mult = multMap[config.screenshotRes] || 2;

      const originalWidth = window.innerWidth;
      const originalHeight = window.innerHeight;
      const originalPixelRatio = renderer.getPixelRatio();

      // Temporarily resize for high-res
      renderer.setPixelRatio(originalPixelRatio * mult);
      renderer.setSize(originalWidth, originalHeight, false);
      composer.setSize(originalWidth * mult, originalHeight * mult);

      // Render one frame
      renderer.autoClear = true;
      composer.render();

      const dataURL = renderer.domElement.toDataURL('image/png');
      const link = document.createElement('a');
      link.download = `echoverse_capture_${mult}x_${Date.now()}.png`;
      link.href = dataURL;
      link.click();

      // Restore original size
      renderer.setPixelRatio(originalPixelRatio);
      renderer.setSize(originalWidth, originalHeight);
      composer.setSize(originalWidth, originalHeight);
    }

    function exportConfig() {
      const configStr = JSON.stringify(config, null, 2);
      navigator.clipboard.writeText(configStr).then(() => {
        alert('Preset copied to clipboard as JSON!');
      });
    }

    function importConfig() {
      const input = prompt('Paste your EchoVerse Preset JSON here:');
      if (!input) return;
      try {
        const newConfig = JSON.parse(input);
        Object.assign(config, newConfig);
        // Refresh systems
        applyColorTheme();
        buildMainGeometry();
        alert('Preset imported successfully!');
      } catch (e) {
        alert('Invalid preset JSON.');
      }
    }

    // Streaming & Webcam logic
    const webcamVideo = document.getElementById('webcam-video');
    const webcamContainer = document.getElementById('webcam-container');
    let webcamStream = null;

    async function toggleWebcam(force = null) {
      const target = force !== null ? force : !config.showWebcam;
      config.showWebcam = target;

      if (target) {
        try {
          webcamStream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } });
          webcamVideo.srcObject = webcamStream;
          webcamContainer.style.display = 'block';
          updateWebcamPosition();
        } catch (e) {
          console.error("Webcam access denied:", e);
          config.showWebcam = false;
        }
      } else {
        if (webcamStream) {
          webcamStream.getTracks().forEach(track => track.stop());
          webcamStream = null;
        }
        webcamContainer.style.display = 'none';
      }
    }

    function updateWebcamPosition() {
      const pos = config.webcamPosition;
      webcamContainer.style.top = pos.includes('top') ? '40px' : 'auto';
      webcamContainer.style.bottom = pos.includes('bottom') ? '40px' : 'auto';
      webcamContainer.style.left = pos.includes('left') ? '40px' : 'auto';
      webcamContainer.style.right = pos.includes('right') ? '40px' : 'auto';
    }

    function updateStreamOverlay() {
      const overlay = document.getElementById('stream-overlay');
      if (config.showStreamOverlay) {
        overlay.style.display = 'block';
        document.getElementById('overlay-title').textContent = config.overlayText;
        document.getElementById('overlay-bpm').style.display = config.showBpmOverlay ? 'block' : 'none';

        if (config.showBpmOverlay) {
          document.getElementById('overlay-bpm').textContent = `${Math.round(audio.bpmSmooth)} BPM`;
          document.getElementById('overlay-energy').textContent = `ENERGY: ${(audio.energy * 100).toFixed(0)}% `;
        }
      } else {
        overlay.style.display = 'none';
      }

      const chroma = document.getElementById('webcam-chroma-overlay');
      chroma.style.display = config.webcamChromaKey ? 'block' : 'none';
    }

    // Build all
    buildMainGeometry(); buildSecondary(); buildWaveformRing(); buildFreqBars(); buildRings();
    buildEnvironment(); buildShockwaves(); buildLightRays(); buildAurora(); buildEnergyField(); buildOrbitals();
    applyColorTheme();

    // Spectrum
    const specCanvas = document.getElementById('spectrum-overlay');
    const specCtx = specCanvas.getContext('2d');
    specCanvas.width = window.innerWidth; specCanvas.height = 50;

    function drawSpectrum() {
      if (!config.showSpectrum || !analyser) { specCanvas.style.opacity = '0'; return; }
      specCanvas.style.opacity = '0.5';
      specCtx.clearRect(0, 0, specCanvas.width, specCanvas.height);
      const barW = specCanvas.width / 64;
      const primary = new THREE.Color(config.colorPrimary), secondary = new THREE.Color(config.colorSecondary);
      for (let i = 0; i < 64; i++) {
        const v = audio.getBand(i), h = v * 48, t = i / 64;
        const col = primary.clone().lerp(secondary, t);
        specCtx.fillStyle = `rgba(${Math.floor(col.r * 255)}, ${Math.floor(col.g * 255)}, ${Math.floor(col.b * 255)}, ${0.25 + v * 0.6})`;
        specCtx.fillRect(i * barW, specCanvas.height - h, barW - 1, h);
      }
    }

    // Camera state
    const camState = {
      angle: 0, targetAngle: 0, height: 0, targetHeight: 0,
      distance: config.cameraDistance, targetDistance: config.cameraDistance,
      look: new THREE.Vector3(), targetLook: new THREE.Vector3(),
      roll: 0, targetRoll: 0, appliedRoll: 0,
      autoMode: config.cameraMode, autoAngleOffset: 0, autoAngleOffsetTarget: 0,
      autoHeightBias: 0, autoHeightBiasTarget: 0, autoRoll: 0, autoRollTarget: 0,
      shake: new THREE.Vector3(), drunk: new THREE.Vector3(),
      profileShake: new THREE.Vector3(),
      dofFocus: config.dofFocusDistance
    };

    // Easing functions
    const camEasing = {
      linear: t => t,
      ease: t => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2,
      bounce: t => {
        const n1 = 7.5625, d1 = 2.75;
        if (t < 1 / d1) return n1 * t * t;
        else if (t < 2 / d1) return n1 * (t -= 1.5 / d1) * t + 0.75;
        else if (t < 2.5 / d1) return n1 * (t -= 2.25 / d1) * t + 0.9375;
        else return n1 * (t -= 2.625 / d1) * t + 0.984375;
      },
      elastic: t => {
        const c4 = (2 * Math.PI) / 3;
        return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
      }
    };

    const cameraPresets = {
      slots: Array(8).fill(null),
      activeSlot: null,
      transition: { active: false, startTime: 0, duration: 2.0, from: null, to: null }
    };

    try {
      const saved = localStorage.getItem('echoVerseCamPresets');
      if (saved) cameraPresets.slots = JSON.parse(saved);
    } catch (e) { }

    function saveCameraPreset(slot) {
      cameraPresets.slots[slot] = {
        distance: camState.distance, angle: camState.angle, height: camState.height, roll: camState.roll, fov: camera.fov,
        position: { x: camera.position.x, y: camera.position.y, z: camera.position.z }
      };
      localStorage.setItem('echoVerseCamPresets', JSON.stringify(cameraPresets.slots));
      updateCamPresetUI();
    }


    function loadCameraPreset(slot, instant = false) {
      const preset = cameraPresets.slots[slot];
      if (!preset) return;
      cameraPresets.activeSlot = slot;

      if (instant) {
        camera.position.set(preset.position.x, preset.position.y, preset.position.z);
        camera.fov = preset.fov;
        camera.updateProjectionMatrix();
        camState.distance = preset.distance;
        camState.angle = preset.angle;
        camState.height = preset.height;
        camState.roll = preset.roll;
      } else {
        // Start smooth transition
        cameraPresets.transition = {
          active: true,
          startTime: performance.now() / 1000,
          duration: config.cameraTransitionDuration,
          from: {
            position: camera.position.clone(),
            fov: camera.fov,
            distance: camState.distance,
            angle: camState.angle,
            height: camState.height,
            roll: camState.roll
          },
          to: preset
        };
      }
      updateCamPresetUI();
    }

    function clearCameraPreset(slot) {
      cameraPresets.slots[slot] = null;
      localStorage.setItem('echoVerseCamPresets', JSON.stringify(cameraPresets.slots));
      updateCamPresetUI();
    }

    function updateCamPresetUI() {
      document.querySelectorAll('.cam-preset-btn').forEach(btn => {
        const slot = parseInt(btn.dataset.slot) - 1;
        btn.style.background = cameraPresets.slots[slot] ?
          'linear-gradient(145deg, rgba(100,200,100,0.4), rgba(80,160,80,0.3))' : '';
        btn.style.borderColor = cameraPresets.activeSlot === slot ?
          'rgba(100,200,100,0.8)' : '';
      });
    }

    // Camera Path Recording System
    const cameraPath = {
      keyframes: [],
      recording: false,
      playing: false,
      playbackTime: 0,
      lastRecordTime: 0,
      recordInterval: 0.1 // Record every 100ms
    };

    function recordCameraKeyframe(time) {
      cameraPath.keyframes.push({
        time: time,
        position: { x: camera.position.x, y: camera.position.y, z: camera.position.z },
        rotation: { x: camera.rotation.x, y: camera.rotation.y, z: camera.rotation.z },
        fov: camera.fov,
        distance: camState.distance,
        angle: camState.angle,
        height: camState.height,
        roll: camState.roll
      });
      updateCamPathStatus();
    }

    function startRecording() {
      cameraPath.keyframes = [];
      cameraPath.recording = true;
      cameraPath.lastRecordTime = 0;
      config.camPathRecording = true;
      document.getElementById('camPathRecord').style.background = 'rgba(255,80,80,0.5)';
      updateCamPathStatus();
    }

    function stopRecording() {
      cameraPath.recording = false;
      config.camPathRecording = false;
      document.getElementById('camPathRecord').style.background = '';
      updateCamPathStatus();
    }

    function startPlayback() {
      if (cameraPath.keyframes.length < 2) return;
      cameraPath.playing = true;
      cameraPath.playbackTime = 0;
      config.camPathPlaying = true;
      document.getElementById('camPathPlay').style.background = 'rgba(80,200,80,0.5)';
    }

    function stopPlayback() {
      cameraPath.playing = false;
      config.camPathPlaying = false;
      document.getElementById('camPathPlay').style.background = '';
    }

    function interpolatePath(t) {
      const kf = cameraPath.keyframes;
      if (kf.length < 2) return null;

      const totalTime = kf[kf.length - 1].time;
      let currentTime = t % totalTime;

      // Find surrounding keyframes
      let i = 0;
      while (i < kf.length - 1 && kf[i + 1].time < currentTime) i++;

      const kf1 = kf[i];
      const kf2 = kf[Math.min(i + 1, kf.length - 1)];
      const localT = kf2.time === kf1.time ? 0 :
        (currentTime - kf1.time) / (kf2.time - kf1.time);

      const easingFn = camEasing[config.cameraTransitionType] || camEasing.ease;
      const eased = easingFn(clamp(localT, 0, 1));

      return {
        position: {
          x: lerp(kf1.position.x, kf2.position.x, eased),
          y: lerp(kf1.position.y, kf2.position.y, eased),
          z: lerp(kf1.position.z, kf2.position.z, eased)
        },
        fov: lerp(kf1.fov, kf2.fov, eased),
        distance: lerp(kf1.distance, kf2.distance, eased),
        angle: lerp(kf1.angle, kf2.angle, eased),
        height: lerp(kf1.height, kf2.height, eased),
        roll: lerp(kf1.roll, kf2.roll, eased)
      };
    }

    function updateCamPathStatus() {
      const statusEl = document.getElementById('camPathStatus');
      if (statusEl) statusEl.textContent = `${cameraPath.keyframes.length} keyframes`;
    }

    // Shake Profiles
    const shakeProfiles = {
      none: () => ({ x: 0, y: 0, z: 0 }),
      earthquake: (t, freq, energy) => ({
        x: Math.sin(t * freq * 15) * 0.3 * energy + Math.sin(t * freq * 23) * 0.15 * energy,
        y: Math.cos(t * freq * 12) * 0.2 * energy + Math.sin(t * freq * 31) * 0.1 * energy,
        z: Math.sin(t * freq * 8) * 0.15 * energy
      }),
      explosion: (t, freq, energy) => {
        const decay = Math.exp(-t * 3);
        return {
          x: (Math.random() - 0.5) * 2 * decay * energy,
          y: (Math.random() - 0.5) * 2 * decay * energy + decay * 0.3 * energy,
          z: (Math.random() - 0.5) * 1.5 * decay * energy
        };
      },
      heartbeat: (t, freq, energy) => {
        const beat = Math.pow(Math.sin(t * freq * 4), 8);
        return {
          x: 0,
          y: beat * 0.15 * energy,
          z: beat * 0.08 * energy
        };
      },
      handheld: (t, freq, energy) => ({
        x: gradNoise(t * freq * 2, 0, 0) * 0.08 * energy,
        y: gradNoise(0, t * freq * 2.3, 0) * 0.06 * energy,
        z: gradNoise(0, 0, t * freq * 1.8) * 0.04 * energy
      })
    };

    function applyShakeProfile(t, dt, energy) {
      const profile = config.shakeProfile;
      if (profile === 'none') {
        camState.profileShake.multiplyScalar(config.shakeDecay);
        return;
      }

      const shakeFn = shakeProfiles[profile];
      if (!shakeFn) return;

      const rawShake = shakeFn(t, config.shakeFrequency, energy * config.cameraShake);
      const bias = config.shakeDirectionBias;

      // Apply directional bias
      const newShake = {
        x: (bias.includes('x') ? rawShake.x : 0),
        y: (bias.includes('y') ? rawShake.y : 0),
        z: (bias.includes('z') ? rawShake.z : 0)
      };

      // Smooth interpolation with decay
      camState.profileShake.x = lerp(camState.profileShake.x, newShake.x, dt * 8);
      camState.profileShake.y = lerp(camState.profileShake.y, newShake.y, dt * 8);
      camState.profileShake.z = lerp(camState.profileShake.z, newShake.z, dt * 8);
      camState.profileShake.multiplyScalar(config.shakeDecay);
    }

    // DOF System
    function updateDOF(energy) {
      if (!config.dofEnabled) return;

      switch (config.dofAutoFocus) {
        case 'center':
          camState.dofFocus = lerp(camState.dofFocus, camState.distance, 0.05);
          break;
        case 'energy':
          // Focus distance varies with audio energy - closer on high energy
          const targetFocus = config.dofFocusDistance * (1 - energy * 0.3);
          camState.dofFocus = lerp(camState.dofFocus, targetFocus, 0.08);
          break;
        case 'manual':
          camState.dofFocus = lerp(camState.dofFocus, config.dofFocusDistance, 0.1);
          break;
      }
    }

    let beatPulse = 0, _lastFrameTime = 0, _animationTime = 0, _lastFFTUpdate = 0, modelSpin = 0;
    // FFT update interval - higher smoothness = less frequent updates
    const getFFTInterval = () => 1000 / (60 - config.smoothness * 30); // 60fps to 30fps
    const _pool = { tmp: new THREE.Vector3(), targetPos: new THREE.Vector3(), axisY: new THREE.Vector3(0, 1, 0), quat: new THREE.Quaternion(), vi: new THREE.Vector3(), vj: new THREE.Vector3() };

    // Presets
    // Presets
    const presets = (() => {
      let p = {};
      try { p = JSON.parse(localStorage.getItem('echoVersePresets') || '{}'); } catch (e) { }
      return p;
    })();

    const openPresetModal = () => { document.getElementById('preset-modal').style.display = 'block'; renderPresetList(); };
    const closePresetModal = () => { document.getElementById('preset-modal').style.display = 'none'; };
    const savePreset = () => {
      const name = document.getElementById('preset-name').value.trim();
      if (!name) return;

      // Generate thumbnail
      const canvas = renderer.domElement;
      const thumb = document.createElement('canvas');
      thumb.width = 320; thumb.height = 180;
      const ctx = thumb.getContext('2d');
      ctx.drawImage(canvas, 0, 0, thumb.width, thumb.height);

      presets[name] = {
        config: JSON.parse(JSON.stringify(config)),
        thumb: thumb.toDataURL('image/webp', 0.5)
      };

      localStorage.setItem('echoVersePresets', JSON.stringify(presets));
      renderPresetList();
    };
    const loadPreset = (name) => {
      if (!presets[name]) return;
      const data = presets[name].config || presets[name]; // Fallback for old presets
      Object.assign(config, data);

      // ... (rest of load logic) ...
      applyColorTheme(); setBgPatternFromConfig(); updateTrailMode();
      buildMainGeometry(); buildRings(); buildEnvironment(); buildShockwaves();
      buildLightRays(); buildAurora(); buildEnergyField(); buildOrbitals();
      if (scene.fog) scene.fog.density = config.fogDensity;
      camera.fov = config.cameraFov; camera.updateProjectionMatrix();
      closePresetModal();
    };
    const deletePreset = (name) => { delete presets[name]; localStorage.setItem('echoVersePresets', JSON.stringify(presets)); renderPresetList(); };

    function renderPresetList() {
      const list = document.getElementById('preset-list');
      list.innerHTML = '';
      list.className = 'preset-grid'; // Use grid style

      Object.keys(presets).forEach(name => {
        const entry = presets[name];
        const card = document.createElement('div');
        card.className = 'preset-card';
        card.innerHTML = `
          < img src = "${entry.thumb || ''}" loading = "lazy" />
            <div class="preset-card__label">
              <span>${name}</span>
              <span class="delete-preset-btn" style="color: #ff4444;" data-name="${name}">✕</span>
            </div>
        `;
        card.querySelector('img').onclick = () => loadPreset(name);
        card.querySelector('.delete-preset-btn').onclick = (e) => {
          e.stopPropagation();
          deletePreset(name);
        };
        list.appendChild(card);
      });
    }

    // Attach listeners for presets
    document.addEventListener('DOMContentLoaded', () => {
      document.getElementById('openPresetModalBtn').addEventListener('click', openPresetModal);
      document.getElementById('closePresetModalBtn').addEventListener('click', closePresetModal);
      document.getElementById('savePresetBtn').addEventListener('click', savePreset);

      // Event delegation for preset list
      document.getElementById('preset-list').addEventListener('click', (e) => {
        if (e.target.classList.contains('load-preset-btn')) {
          loadPreset(e.target.dataset.name);
        } else if (e.target.classList.contains('delete-preset-btn')) {
          deletePreset(e.target.dataset.name);
        }
      });
    });

    function randomize() {
      const forms = ['icosahedron', 'octahedron', 'dodecahedron', 'torus', 'torusKnot', 'sphere', 'mobius', 'gyroid', 'hopfFibration', 'seashell'];
      const themes = Object.keys(colorThemes);
      const cameras = ['orbit', 'reactive', 'cinematic', 'spiral', 'figure8', 'vortex', 'pendulum'];
      const particles = ['vertex', 'swarm', 'explode', 'orbital', 'magnetic', 'wave', 'vortex', 'aurora'];
      const trails = ['none', 'light', 'medium', 'heavy', 'smear'];
      const envs = ['void', 'stars', 'nebula', 'grid'];
      const patterns = ['none', 'mandala', 'lattice', 'plasma', 'voronoi', 'waves'];

      config.form = forms[Math.floor(Math.random() * forms.length)];
      config.density = Math.floor(Math.random() * 4) + 1;
      config.colorTheme = themes[Math.floor(Math.random() * themes.length)];
      config.cameraMode = cameras[Math.floor(Math.random() * cameras.length)];
      config.particleMode = particles[Math.floor(Math.random() * particles.length)];
      config.trailMode = trails[Math.floor(Math.random() * trails.length)];
      config.environment = envs[Math.floor(Math.random() * envs.length)];
      config.bgPattern = patterns[Math.floor(Math.random() * patterns.length)];
      config.symmetry = [3, 4, 6, 8, 12][Math.floor(Math.random() * 5)];
      config.sensitivity = 0.6 + Math.random() * 1.8;
      config.turbulence = Math.random() * 1.5;
      config.bloomStrength = 0.4 + Math.random() * 1.2;
      config.cameraSpeed = 0.3 + Math.random() * 1.2;
      config.cameraShake = Math.random() * 1.0;
      config.bgPatternStrength = 0.1 + Math.random() * 0.5;
      config.showLightRays = Math.random() > 0.7;
      config.showAurora = Math.random() > 0.7;
      config.showEnergyField = Math.random() > 0.8;
      config.showOrbitals = Math.random() > 0.7;

      applyColorTheme(); setBgPatternFromConfig(); updateTrailMode();
      buildMainGeometry(); buildRings(); buildEnvironment(); buildShockwaves();
      buildLightRays(); buildAurora(); buildEnergyField(); buildOrbitals();

      document.getElementById('form').value = config.form;
      document.getElementById('colorTheme').value = config.colorTheme;
      document.getElementById('cameraMode').value = config.cameraMode;
      document.getElementById('particleMode').value = config.particleMode;
      document.getElementById('trailMode').value = config.trailMode;
      document.getElementById('environment').value = config.environment;
      document.getElementById('bgPattern').value = config.bgPattern;
    }
    // Animation loop
    function animate(timestamp) {
      if (document.body.classList.contains('loading')) {
        document.body.classList.remove('loading');
      }
      requestAnimationFrame(animate);
      if (!timestamp) timestamp = performance.now();
      const rawDt = _lastFrameTime ? (timestamp - _lastFrameTime) / 1000 : 0.016;
      const dt = Math.min(rawDt, 0.05);
      _lastFrameTime = timestamp;
      _animationTime += dt;
      const t = _animationTime;

      // Smooth continuous model spin (decoupled from beat phase/BPM estimation)
      if (config.modelSpinEnabled) {
        modelSpin += dt * (0.24 * config.cameraSpeed * config.modelSpinSpeed); // continuous; speed is user-controlled
      }

      // Beat pulse decay is handled after beat detection for better timing

      let isBeat = false;
      if (analyser && playing) {
        if ((timestamp - _lastFFTUpdate) >= getFFTInterval()) {
          _lastFFTUpdate = timestamp;
          analyser.getByteFrequencyData(freqData);
          analyser.getByteTimeDomainData(timeData);
        }
        // Smoothing alpha adjusted by global smoothness setting
        const smoothingAlpha = 0.18 + config.smoothness * 0.15; // 0.18 to 0.33
        isBeat = audio.analyze(freqData, timeData, dt, null, null, smoothingAlpha);

        // Update motion coordinator with smoothness setting
        motion.update(audio, dt, music.phase, config.smoothness);

        // Update professional analysis
        if (window.analysisManager) window.analysisManager.update(audio, dt);

        document.getElementById('bpm-display').textContent = `${audio.getBPM()} BPM`;
        document.getElementById('energy-display').textContent = `Energy: ${(audio.energy * 100).toFixed(0)}% `;
        document.getElementById('bar-display').textContent = `Bar: ${audio.barCount} `;
        document.getElementById('note-display').textContent = `Note: ${audio.noteName} `;

        // Update progress bar
        const progressPercent = (audioEl.currentTime / audioEl.duration) * 100 || 0;
        if (audioEl.duration) {
          document.getElementById('audio-progress').style.width = `${progressPercent}% `;
          document.getElementById('current-time').textContent = formatTime(audioEl.currentTime);
          document.getElementById('duration').textContent = formatTime(audioEl.duration);
        }
        document.getElementById('zen-progress').style.width = `${progressPercent}% `;
      }
      updateMusicClock(dt);

      if (config.hueRotateSpeed > 0) { palette.globalHueShift += dt * config.hueRotateSpeed * 0.1; palette.globalHueShift = fract(palette.globalHueShift); }

      if (audio.barCount !== music.lastSeenBar) {
        music.lastSeenBar = audio.barCount;
        if (config.barLockColors) palette.hOffsetTarget = (hash1(audio.barCount * 0.97) - 0.5) * 0.10;
        if (config.cameraAutoAngles && audio.barCount > 0 && audio.barCount % 16 === 0) {
          const modes = ['orbit', 'reactive', 'cinematic', 'spiral', 'figure8', 'vortex', 'pendulum'];
          camState.autoMode = modes[Math.floor(Math.random() * modes.length)];
          camState.autoAngleOffsetTarget = (Math.random() * 2 - 1) * (Math.PI * 0.45);
          camState.autoHeightBiasTarget = (Math.random() * 2 - 1) * 7.0;
          camState.autoRollTarget = (Math.random() * 2 - 1) * (Math.PI / 18);
        }
      }
      palette.hOffset = lerp(palette.hOffset, palette.hOffsetTarget, dt * 0.8);

      const { smoothSubBass, smoothBass, smoothLowMid, smoothMid, smoothHighMid, smoothHigh, smoothBrilliance, spectralCentroid, spectralFlux, energy, transientSharpness, onsetSnare, onsetHihat } = audio;
      const phase = music.phase;
      const sens = config.sensitivity;
      const symN = config.symmetry;

      // Use motion coordinator's pulse instead of raw beatPulse
      // This is pre-smoothed and won't conflict with other systems
      beatPulse = motion.pulse;

      // Spawn shockwave on coordinator's beat, not raw audio
      // Shockwave triggers (beat + transients), with cooldown for stability
      if (config.showShockwaves) {
        const canSpawn = (t - shockState.lastTime) > config.shockwaveCooldown;
        const strongTransient = motion.impact > config.shockwaveImpactThreshold;
        if (canSpawn && (isBeat || strongTransient)) {
          shockState.lastTime = t;
          const col = getHarmonizedColor(energy, 0.5);
          spawnShockwave(col, isBeat ? 1.0 : 0.75);
        }
      }

      // Update background - use motion coordinator values
      bgUniforms.uTime.value = t;
      bgUniforms.uPhase.value = phase;
      bgUniforms.uSymmetry.value = symN;
      bgUniforms.uEnergy.value = motion.swell; // Smooth swell instead of raw energy
      bgUniforms.uBass.value = motion.lowMotion;
      bgUniforms.uMid.value = motion.midMotion;
      bgUniforms.uHigh.value = motion.highMotion;
      bgUniforms.uNegative.value = config.negativeSpace ? 1.0 : 0.0;
      bgUniforms.uBeatPulse.value = motion.pulse;
      bgUniforms.uReactiveBg.value = config.reactiveBg ? 1.0 : 0.0;
      bgUniforms.uPatternStrength.value = config.bgPatternStrength;

      // Main geometry - USE MOTION COORDINATOR for scale (single source of truth)
      if (wireframeMesh && particleSystem) {
        const rotBase = 0.55 * config.cameraSpeed;

        // Rotation driven by TIME and mid frequencies, NOT beats
        // This creates smooth, continuous rotation that doesn't jerk
        // NOTE: we use modelSpin (time-integrated radians) instead of music.phase.
        // music.phase is beat/BPM-driven and can re-time when BPM smoothing shifts.
        const react = (config.modelSpinReactive ? config.modelSpinReactivity : 0);
        const baseY = modelSpin;
        const baseX = modelSpin * 0.455;
        const baseZ = modelSpin * 0.273;

        const centroidFactor = lerp(1.0, (0.85 + 0.35 * spectralCentroid), react);

        let rotY = baseY + motion.midMotion * 0.06 * react;
        let rotX = baseX * centroidFactor;
        let rotZ = baseZ + motion.highMotion * 0.04 * react;

        if (config.modelSpinAxis === 'y') {
          rotX = 0;
          rotZ = 0;
        }

        wireframeMesh.rotation.y = rotY;
        wireframeMesh.rotation.x = rotX;
        wireframeMesh.rotation.z = rotZ;

        // SINGLE scale source from motion coordinator
        const targetScale = motion.scaleSuggestion * (0.95 + sens * 0.05);
        const pulseAmt = (config.modelPulseEnabled ? config.modelPulseAmount : 0);
        const meshScale = lerp(1.0, targetScale, pulseAmt);
        wireframeMesh.scale.setScalar(meshScale);

        wireframeMesh.material.opacity = config.negativeSpace ? 0.12 : (0.22 + motion.swell * 0.42);
        wireframeMesh.material.color.copy(config.negativeSpace ? new THREE.Color(0x080808) : getHarmonizedColor(motion.swell, 0.5));

        if (rimMesh) {
          rimMesh.visible = config.negativeSpace;
          rimMesh.rotation.copy(wireframeMesh.rotation);
          rimMesh.scale.copy(wireframeMesh.scale);
          rimMesh.material.uniforms.uColor.value.copy(getHarmonizedColor(motion.swell, 0.5));
          rimMesh.material.uniforms.uTime.value = t;
        }

        // Advanced Dynamic Particles - Web Worker Physics & GPU Instancing
        if (dynamicParticles) dynamicParticles.update(dt, t, audio);

        // Final background/fog color sync
        if (scene.fog) scene.fog.color.copy(bgUniforms.uBgColor.value);
        renderer.setClearColor(bgUniforms.uBgColor.value);
      }

      // Connection lines - use motion coordinator
      if (connectionLines && config.showConnections && vertexData.length > 1) {
        const linePos = connectionLines.geometry.attributes.position.array;
        const lineCol = connectionLines.geometry.attributes.color.array;
        let lineIdx = 0;
        // Smoother connection distance using motion values
        const maxDist = 3.5 + motion.midMotion * 4.0 + motion.pulse * 2.0;
        _pool.quat.setFromEuler(wireframeMesh.rotation);
        const scale = wireframeMesh.scale.x;
        const limit = Math.min(vertexData.length, 150);

        for (let i = 0; i < limit && lineIdx < linePos.length / 6; i++) {
          for (let j = i + 1; j < limit && lineIdx < linePos.length / 6; j++) {
            _pool.vi.copy(vertexData[i].current).multiplyScalar(scale).applyQuaternion(_pool.quat);
            _pool.vj.copy(vertexData[j].current).multiplyScalar(scale).applyQuaternion(_pool.quat);
            const d = _pool.vi.distanceTo(_pool.vj);
            if (d < maxDist) {
              linePos[lineIdx * 6] = _pool.vi.x; linePos[lineIdx * 6 + 1] = _pool.vi.y; linePos[lineIdx * 6 + 2] = _pool.vi.z;
              linePos[lineIdx * 6 + 3] = _pool.vj.x; linePos[lineIdx * 6 + 4] = _pool.vj.y; linePos[lineIdx * 6 + 5] = _pool.vj.z;
              const bright = clamp((maxDist - d) / maxDist, 0, 1) * 0.24 + 0.03;
              const c = getHarmonizedColor(energy, 0.5);
              lineCol[lineIdx * 6] = lineCol[lineIdx * 6 + 3] = c.r * bright;
              lineCol[lineIdx * 6 + 1] = lineCol[lineIdx * 6 + 4] = c.g * bright;
              lineCol[lineIdx * 6 + 2] = lineCol[lineIdx * 6 + 5] = c.b * bright;
              lineIdx++;
            }
          }
        }
        connectionLines.geometry.setDrawRange(0, lineIdx * 2);
        connectionLines.geometry.attributes.position.needsUpdate = true;
        connectionLines.geometry.attributes.color.needsUpdate = true;
      }

      // Secondary meshes - use motion coordinator for smooth, non-competing motion
      if (innerMesh) {
        innerMesh.rotation.y = phase * 0.05;
        innerMesh.rotation.x = phase * 0.03;
        // Use motion.pulse instead of raw audio
        innerMesh.scale.setScalar(1 + motion.lowMotion * 0.25 + motion.pulse * 0.15);
        innerMesh.material.color.copy(getHarmonizedColor(motion.lowMotion, 0.2));
        innerMesh.material.opacity = 0.12 + motion.swell * 0.12;
      }
      if (outerMesh) {
        outerMesh.rotation.y = -phase * 0.02;
        outerMesh.rotation.z = phase * 0.015;
        outerMesh.scale.setScalar(1 + motion.lowMotion * 0.15 + motion.breathe * 0.08);
        outerMesh.material.opacity = 0.03 + motion.swell * 0.03;
      }

      // Waveform ring - still uses raw timeData for accurate waveform, but scaling is smoothed
      if (waveformRing && waveformRing.visible && timeData) {
        const wPos = waveformRing.geometry.attributes.position.array;
        const baseRadius = 12;
        const waveAmplitude = 3.5 * (1 + motion.swell * 0.4);

        for (let i = 0; i < 256; i++) {
          const ang = (i / 256) * TAU;
          const dataIdx = Math.floor(i * timeData.length / 256);
          const sample = (timeData[dataIdx] / 128 - 1);
          const prevSample = (timeData[Math.max(0, dataIdx - 1)] / 128 - 1);
          const nextSample = (timeData[Math.min(timeData.length - 1, dataIdx + 1)] / 128 - 1);
          const smoothedSample = (prevSample + sample * 2 + nextSample) / 4;

          const r = baseRadius + smoothedSample * waveAmplitude;
          wPos[i * 3] = Math.cos(ang) * r;
          wPos[i * 3 + 2] = Math.sin(ang) * r;
          wPos[i * 3 + 1] = smoothedSample * 0.4 * motion.highMotion;
        }
        waveformRing.geometry.attributes.position.needsUpdate = true;
        waveformRing.material.color.copy(getHarmonizedColor(motion.midMotion, 0.7));
        waveformRing.material.opacity = 0.35 + motion.swell * 0.2;
      }

      // Freq bars - smoothed transitions
      freqBars.forEach((bar, idx) => {
        if (!bar.visible) return;
        const v = audio.getBand(idx);
        const peak = audio.bandPeaks[idx];
        const targetScale = 0.5 + v * 8 + (peak - v) * 1.5;
        bar.scale.y = lerp(bar.scale.y, targetScale, 0.25);
        bar.material.color.copy(getHarmonizedColor(v, idx / 64));
        bar.material.opacity = 0.35 + v * 0.45;
      });

      // Rings - use motion coordinator
      rings.forEach((ring, idx) => {
        ring.rotation.x = phase * 0.02 * (idx + 1) + Math.PI / 2 * (idx % 2);
        ring.rotation.y = phase * 0.015 * (idx + 1);
        const bandVal = audio.getBand(idx * 8);
        ring.scale.setScalar(1 + bandVal * 0.3 + motion.pulse * 0.1);
        ring.material.color.copy(getHarmonizedColor(bandVal, idx / config.ringCount));
        ring.material.opacity = 0.02 + bandVal * 0.025;
      });

      // Light rays - smoother motion
      lightRays.forEach((ray, i) => {
        ray.rotation.z = ray.userData.baseAngle + t * ray.userData.speed * (1 + motion.lowMotion * 0.3);
        const intensity = 0.1 + motion.midMotion * 0.3 + motion.pulse * 0.15;
        ray.material.uniforms.uIntensity.value = intensity;
        ray.material.uniforms.uColor.value.copy(getHarmonizedColor(motion.midMotion, i / 12));
      });

      // Aurora - use motion coordinator
      if (auroraLayer) {
        auroraLayer.material.uniforms.uTime.value = t;
        auroraLayer.material.uniforms.uEnergy.value = motion.swell;
        auroraLayer.material.uniforms.uColorA.value.copy(new THREE.Color(config.colorPrimary));
        auroraLayer.material.uniforms.uColorB.value.copy(new THREE.Color(config.colorSecondary));
      }

      // Energy field - use motion coordinator
      if (energyFieldMesh) {
        energyFieldMesh.material.uniforms.uTime.value = t;
        energyFieldMesh.material.uniforms.uEnergy.value = motion.swell;
        energyFieldMesh.material.uniforms.uColor.value.copy(getHarmonizedColor(motion.swell, 0.5));
        energyFieldMesh.rotation.y = t * 0.1;
        energyFieldMesh.rotation.x = t * 0.05;
      }

      // Orbitals - use motion coordinator
      orbitalRings.forEach((ring, i) => {
        ring.rotation.x = t * ring.userData.speed;
        ring.rotation.z = t * ring.userData.speed * 0.7;
        ring.material.color.copy(getHarmonizedColor(motion.midMotion, i / 3));
        ring.material.opacity = 0.08 + motion.swell * 0.15;
      });

      // Dynamic Particles
      if (dynamicParticles) dynamicParticles.update(dt, t, audio);

      // Shockwaves
      shockwaves.forEach(s => {
        if (!s.active) return;
        s.life -= dt * 1.8;
        if (s.life <= 0) { s.active = false; s.mesh.material.uniforms.uOpacity.value = 0; return; }
        // Always face camera so the rings read cleanly from any orbit angle
        s.mesh.quaternion.copy(camera.quaternion);
        s.mesh.scale.addScalar(dt * 22);
        s.mesh.material.uniforms.uOpacity.value = s.life * config.shockwaveIntensity * (s.strength || 1.0);
      });

      // Floating particles - smoother motion
      if (floatingParticles) {
        const fp = floatingParticles.geometry.attributes.position.array;
        const fc = floatingParticles.geometry.attributes.color.array;
        floatingData.forEach((fd, i) => {
          fd.theta += fd.speed * dt * 0.25;
          fd.phi += fd.speed * dt * 0.12;
          const bv = audio.getBand(fd.band);
          // Smoother radius modulation
          const rr = fd.r * (1 + bv * 0.2 + motion.swell * 0.1);
          fp[i * 3] = rr * Math.sin(fd.phi) * Math.cos(fd.theta);
          fp[i * 3 + 1] = rr * Math.sin(fd.phi) * Math.sin(fd.theta);
          fp[i * 3 + 2] = rr * Math.cos(fd.phi);
          const c = getHarmonizedColor(bv * 0.7, fd.band / 64);
          fc[i * 3] = c.r; fc[i * 3 + 1] = c.g; fc[i * 3 + 2] = c.b;
        });
        floatingParticles.geometry.attributes.position.needsUpdate = true;
        floatingParticles.geometry.attributes.color.needsUpdate = true;
      }

      // Environment
      envObjects.forEach(obj => {
        if (obj.userData && obj.userData.rotSpeed) { obj.rotation.y += obj.userData.rotSpeed; obj.rotation.x += obj.userData.rotSpeed * 0.5; }
      });
      // === ADVANCED CAMERA LOGIC ===
      const mode = camState.autoMode;
      const camPhase = music.phase;
      const cSpeed = config.cameraSpeed;
      const cShake = config.cameraShake;

      // Path recording
      if (cameraPath.recording && (t - cameraPath.lastRecordTime) > cameraPath.recordInterval) {
        cameraPath.lastRecordTime = t;
        recordCameraKeyframe(t);
      }

      // Determine target values based on playback/transition/mode
      if (cameraPath.playing) {
        const p = interpolatePath(t);
        if (p) {
          camState.targetAngle = p.angle;
          camState.targetHeight = p.height;
          camState.targetDistance = p.distance;
          camState.targetRoll = p.roll;
          camera.fov = p.fov;
          camera.updateProjectionMatrix();
        }
      } else if (cameraPresets.transition.active) {
        const trans = cameraPresets.transition;
        const elapsed = (performance.now() / 1000) - trans.startTime;
        const alpha = clamp(elapsed / trans.duration, 0, 1);
        const easingFn = camEasing[config.cameraTransitionType] || camEasing.ease;
        const eased = easingFn(alpha);

        camState.targetAngle = lerp(trans.from.angle, trans.to.angle, eased);
        camState.targetHeight = lerp(trans.from.height, trans.to.height, eased);
        camState.targetDistance = lerp(trans.from.distance, trans.to.distance, eased);
        camState.targetRoll = lerp(trans.from.roll, trans.to.roll, eased);
        camera.fov = lerp(trans.from.fov, trans.to.fov, eased);
        camera.updateProjectionMatrix();

        if (alpha >= 1.0) trans.active = false;
      } else {
        switch (mode) {
          case 'orbit':
            camState.targetAngle = camPhase * 0.08 * cSpeed + camState.autoAngleOffset;
            camState.targetHeight = Math.sin(camPhase * 0.04 * cSpeed) * 8 + camState.autoHeightBias;
            camState.targetDistance = config.cameraDistance;
            break;
          case 'reactive':
            camState.targetAngle = camPhase * 0.06 * cSpeed + motion.swell * 0.3 + camState.autoAngleOffset;
            camState.targetHeight = motion.midMotion * 6 - 1 + camState.autoHeightBias;
            camState.targetDistance = config.cameraDistance - motion.swell * 4;
            camState.targetRoll = (motion.highMotion - 0.3) * 0.08;
            break;
          case 'cinematic':
            camState.targetAngle = Math.sin(camPhase * 0.02 * cSpeed) * 1.2 + camState.autoAngleOffset;
            camState.targetHeight = Math.cos(camPhase * 0.015 * cSpeed) * 6 + 2 + camState.autoHeightBias;
            camState.targetDistance = config.cameraDistance + Math.sin(camPhase * 0.01) * 5;
            break;
          case 'spiral':
            camState.targetAngle = camPhase * 0.12 * cSpeed + camState.autoAngleOffset;
            camState.targetHeight = Math.sin(camPhase * 0.08 * cSpeed) * 12 + camState.autoHeightBias;
            camState.targetDistance = config.cameraDistance + Math.cos(camPhase * 0.06) * 8;
            break;
          case 'figure8':
            camState.targetAngle = Math.sin(camPhase * 0.05 * cSpeed) * 1.5 + camState.autoAngleOffset;
            camState.targetHeight = Math.sin(camPhase * 0.1 * cSpeed) * Math.cos(camPhase * 0.05 * cSpeed) * 10 + camState.autoHeightBias;
            camState.targetDistance = config.cameraDistance;
            break;
          case 'vortex':
            camState.targetAngle = camPhase * 0.15 * cSpeed + motion.swell * 0.8 + camState.autoAngleOffset;
            camState.targetHeight = motion.highMotion * 5 + camState.autoHeightBias;
            camState.targetDistance = config.cameraDistance - motion.swell * 6;
            camState.targetRoll = camPhase * 0.02 * cSpeed;
            break;
          case 'pendulum':
            camState.targetAngle = Math.sin(camPhase * 0.04 * cSpeed) * 2 + camState.autoAngleOffset;
            camState.targetHeight = Math.abs(Math.sin(camPhase * 0.04 * cSpeed)) * 15 - 5 + camState.autoHeightBias;
            camState.targetDistance = config.cameraDistance;
            break;
          case 'flythrough':
            camState.targetAngle = camPhase * 0.1 * cSpeed + camState.autoAngleOffset;
            camState.targetHeight = Math.sin(camPhase * 0.05 * cSpeed) * 5 + camState.autoHeightBias;
            camState.targetDistance = config.cameraDistance + Math.sin(camPhase * 0.08 * cSpeed) * 15;
            break;
          case 'drunk':
            camState.drunk.x = lerp(camState.drunk.x, (Math.random() - 0.5) * 0.8, dt * 0.5);
            camState.drunk.y = lerp(camState.drunk.y, (Math.random() - 0.5) * 0.6, dt * 0.5);
            camState.drunk.z = lerp(camState.drunk.z, (Math.random() - 0.5) * 0.4, dt * 0.5);
            camState.targetAngle = camPhase * 0.05 * cSpeed + camState.drunk.x + camState.autoAngleOffset;
            camState.targetHeight = camState.drunk.y * 10 + camState.autoHeightBias;
            camState.targetDistance = config.cameraDistance + camState.drunk.z * 10;
            camState.targetRoll = camState.drunk.z * 0.3 + camState.autoRoll;
            break;
          case 'preset':
            // Handled above via transitions or path playback
            break;
        }
      }

      // Beat zoom
      if (config.cameraBeatZoom) {
        camState.targetDistance += motion.zoomSuggestion * 8;
      }

      // Apply smoothing
      const cSmooth = config.smoothness;
      const camLerpBase = 1.8 - cSmooth * 1.0;
      const camLerpSlow = camLerpBase * 0.8;

      camState.angle = lerp(camState.angle, camState.targetAngle, dt * camLerpBase);
      camState.height = lerp(camState.height, camState.targetHeight, dt * camLerpSlow);
      camState.distance = lerp(camState.distance, camState.targetDistance, dt * camLerpSlow);
      camState.roll = lerp(camState.roll, camState.targetRoll + camState.autoRoll, dt * camLerpSlow * 0.8);
      camState.look.lerp(camState.targetLook, dt * camLerpSlow);

      // Advanced Shake
      applyShakeProfile(t, dt, energy);

      // Standard Shake logic
      const shakeMultiplier = 1.0 - cSmooth * 0.9;
      if (cShake > 0 && shakeMultiplier > 0.05) {
        const shakeAmt = motion.impact * cShake * 0.12 * shakeMultiplier;
        const shakeLerp = dt * (3.0 - cSmooth * 2.0);
        camState.shake.x = lerp(camState.shake.x, (Math.random() - 0.5) * shakeAmt, shakeLerp);
        camState.shake.y = lerp(camState.shake.y, (Math.random() - 0.5) * shakeAmt, shakeLerp);
        camState.shake.z = lerp(camState.shake.z, (Math.random() - 0.5) * shakeAmt * 0.2, shakeLerp);
      } else {
        camState.shake.multiplyScalar(0.95);
      }

      // Final camera position
      camera.position.x = Math.cos(camState.angle) * camState.distance + camState.shake.x + camState.profileShake.x;
      camera.position.y = camState.height + camState.shake.y + camState.profileShake.y;
      camera.position.z = Math.sin(camState.angle) * camState.distance + camState.shake.z + camState.profileShake.z;
      camera.lookAt(camState.look);
      camState.appliedRoll = lerp(camState.appliedRoll, camState.roll, dt * 2);
      camera.rotation.z = camState.appliedRoll;

      // Depth of Field
      updateDOF(energy);
      if (bokehPass) {
        bokehPass.enabled = config.dofEnabled;
        bokehPass.uniforms.focus.value = camState.dofFocus;
        bokehPass.uniforms.aperture.value = config.dofAperture;
        bokehPass.uniforms.maxblur.value = config.dofBokehScale;
      }

      // Update Lighting Reactivity
      if (keyLight) keyLight.intensity = config.lightKeyInt * (1.0 + motion.swell * 0.5);
      if (fillLight) fillLight.intensity = config.lightFillInt * (1.0 + motion.lowMotion * 0.3);
      if (rimLight) {
        rimLight.intensity = config.lightRimInt * (1.0 + motion.impact * 0.8);
        // Gently move rim light with camera for consistent highlight
        rimLight.position.x = Math.cos(camState.angle + Math.PI) * 15;
        rimLight.position.z = Math.sin(camState.angle + Math.PI) * 15;
      }

      if (projectorLight) {
        if (config.goboMode !== 'none') {
          projectorLight.intensity = (0.5 + motion.pulse * 0.5) * 5.0;
          projectorLight.position.x = Math.sin(t * 0.5) * 10;
          projectorLight.position.z = Math.cos(t * 0.3) * 10;
        } else {
          projectorLight.intensity = 0;
        }
      }

      // Update Post-processing and Atmosphere
      lightRays.forEach(ray => {
        if (ray.material.uniforms.uIntensity) {
          const base = ray.userData.baseIntensity || 0.3;
          ray.material.uniforms.uIntensity.value = base * config.godRaysInt * (1.0 + motion.pulse * 0.5);
        }
      });

      // Post-processing - uses motion coordinator for smooth, non-competing effects
      bloomPass.strength = config.bloomStrength * (1 + motion.pulse * 0.2);
      bloomPass.radius = config.bloomRadius;
      screenFXPass.uniforms.uTime.value = t;
      screenFXPass.uniforms.uVignette.value = config.vignette;
      screenFXPass.uniforms.uGrain.value = config.grain;
      screenFXPass.uniforms.uAberration.value = config.aberration;
      screenFXPass.uniforms.uHigh.value = motion.highMotion;
      screenFXPass.uniforms.uAnamorphic.value = config.anamorphic;
      screenFXPass.uniforms.uScanlines.value = config.scanlines;
      screenFXPass.uniforms.uBeatPulse.value = config.beatFlash ? motion.pulse : 0;
      screenFXPass.uniforms.uGlitch.value = config.glitchAmount * (1 + motion.impact * 0.5);
      screenFXPass.uniforms.uKaleidoscope.value = config.visualMode === 'kaleidoscope' ? 1.0 : 0.0;
      screenFXPass.uniforms.uKaleidoscopeSegments.value = config.symmetry;
      screenFXPass.uniforms.uNegative.value = config.negativeSpace ? 1.0 : 0.0;
      const filmMap = { none: 0, cinematic: 1, vintage: 2, neon: 3, dream: 4 };
      screenFXPass.uniforms.uFilmLook.value = filmMap[config.filmLook] || 0;

      drawSpectrum();
      composer.render();
      updateHistogram();

      // Monitor Draw Calls
      const calls = renderer.info.render.calls;
      if (calls > 50) {
        if (!window._drawCallWarned) {
          console.warn(`High draw calls detected: ${calls}. Optimizing...`);
          window._drawCallWarned = true;
        }
      }

      // Status Bar logic update
      const statusEl = document.getElementById('status');
      if (playing) {
        statusEl.classList.add('playing');
        if (isBeat) {
          statusEl.classList.add('active-beat');
          setTimeout(() => statusEl.classList.remove('active-beat'), 400);
        }
      }
    }

    animate();
    // UI Bindings
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.settings-panel').forEach(p => p.classList.remove('active'));
        tab.classList.add('active');
        document.querySelector(`.settings - panel[data - panel="${tab.dataset.tab}"]`).classList.add('active');
      });
    });

    document.querySelectorAll('.toggle').forEach(toggle => {
      toggle.addEventListener('click', () => toggle.classList.toggle('active'));
    });

    // Status Bar Hover & Auto-hide Persistence
    let statusHideTimer;
    const statusEl = document.getElementById('status');
    function resetStatusTimer() {
      if (playing) return;
      clearTimeout(statusHideTimer);
      statusHideTimer = setTimeout(() => {
        if (!statusEl.matches(':hover')) statusEl.classList.remove('playing');
      }, 3000);
    }
    statusEl.addEventListener('mousemove', resetStatusTimer);

    // Sync new layer sliders to config defaults
    const _psm = document.getElementById('particleSizeMult'); if (_psm) _psm.value = config.particleSizeMult;
    const _pbr = document.getElementById('particleBrightness'); if (_pbr) _pbr.value = config.particleBrightness;
    const _swi = document.getElementById('shockwaveIntensity'); if (_swi) _swi.value = config.shockwaveIntensity;
    const _swt = document.getElementById('shockwaveImpactThreshold'); if (_swt) _swt.value = config.shockwaveImpactThreshold;
    // Generic binding handler
    function handleBinding(e) {
      const el = e.target;
      const key = el.dataset.bind || el.id;
      if (!key) return;

      let val;
      if (el.classList.contains('toggle')) {
        val = el.classList.contains('active');
      } else if (el.type === 'range' || el.type === 'number') {
        val = parseFloat(el.value);
        if (['density', 'particleCount', 'ringCount', 'symmetry', 'analyzerFftSize'].includes(key)) {
          val = parseInt(el.value);
        }
      } else if (el.type === 'color') {
        val = el.value;
      } else if (el.tagName === 'SELECT') {
        val = el.value;
        if (!isNaN(val) && val !== '' && key !== 'cameraMode' && key !== 'form' && key !== 'renderStyle' && key !== 'environment' && key !== 'bgPattern' && key !== 'filmLook' && key !== 'trailMode' && key !== 'spectrogramMode' && key !== 'spectrogramColor') {
          val = parseFloat(val);
        }
      } else {
        val = el.value;
      }

      // Update config
      if (key in config) {
        config[key] = val;
      } else {
        // Handle mapped keys if they don't match config directly
        const keyMap = {
          toggleBars: 'showBars',
          toggleWireframe: 'showWireframeCore',
          toggleRimGlow: 'showRimGlow',
          toggleDeepParticles: 'showDeepParticles',
          toggleRings: 'showRings',
          toggleModelSpin: 'modelSpinEnabled',
          toggleModelSpinReactive: 'modelSpinReactive',
          toggleModelPulse: 'modelPulseEnabled',
          toggleBarLockColors: 'barLockColors',
          toggleBeatZoom: 'cameraBeatZoom',
          toggleAutoAngles: 'cameraAutoAngles',
          toggleInner: 'showInner',
          toggleOuter: 'showOuter',
          toggleWaveform: 'showWaveform',
          toggleConnections: 'showConnections',
          toggleParticles: 'showParticles',
          toggleShockwaves: 'showShockwaves',
          toggleLightRays: 'showLightRays',
          toggleAurora: 'showAurora',
          toggleEnergyField: 'showEnergyField',
          toggleOrbitals: 'showOrbitals',
          toggleReactiveBg: 'reactiveBg',
          toggleSpectrum: 'showSpectrum',
          toggleAutoPilot: 'autoPilot',
          toggleBeatFlash: 'beatFlash',
          toggleColorCycle: 'colorCycle',
          toggleSynesthesia: 'synesthesia',
          toggleHarmonicSnap: 'harmonicSnap',
          toggleNegativeSpace: 'negativeSpace',
          toggleAnalysisMeters: 'showAnalysisMeters',
          toggleStereoWave: 'showStereoWave',
          toggleHDRI: 'showHDRI',
          toggleDOF: 'dofEnabled',
          toggleCamPathLoop: 'camPathLoop',
          toggleDynParticles: 'dynamicParticlesEnabled',
          toggleDynCollisions: 'dynCollisionEnabled',
          toggleDynAudioSpawn: 'dynAudioReactiveSpawn',
          toggleStreamOverlay: 'showStreamOverlay',
          toggleBpmOverlay: 'showBpmOverlay',
          toggleWebcam: 'showWebcam', // Assuming a config for webcam visibility
          toggleWebcamChroma: 'webcamChromaKey'
        };
        if (keyMap[key]) config[keyMap[key]] = val;
      }

      // Trigger side effects
      const callbacks = {
        form: () => buildMainGeometry(),
        density: () => buildMainGeometry(),
        particleCount: () => buildMainGeometry(),
        renderStyle: () => buildMainGeometry(),
        environment: () => buildMainGeometry(),
        colorTheme: () => applyColorTheme(),
        bgPattern: () => setBgPatternFromConfig(),
        trailMode: () => updateTrailMode(),
        volume: () => { if (gainNode) gainNode.gain.value = config.volume; },
        colorBg: () => { scene.fog && scene.fog.color.set(config.colorBg); bgUniforms.uBgColor.value.set(config.colorBg); },
        colorPrimary: () => { bgUniforms.uAccentA.value.set(config.colorPrimary); },
        colorSecondary: () => { bgUniforms.uAccentB.value.set(config.colorSecondary); },
        cameraFov: () => { camera.fov = config.cameraFov; camera.updateProjectionMatrix(); },
        fogDensity: () => { if (scene.fog) scene.fog.density = config.fogDensity; },
        ringCount: () => buildRings(),
        analyzerFftSize: () => {
          if (audioCtx) {
            analyser.fftSize = parseInt(val);
            if (analyserL) analyserL.fftSize = analyser.fftSize;
            if (analyserR) analyserR.fftSize = analyser.fftSize;
            freqData = new Uint8Array(analyser.frequencyBinCount);
            timeData = new Uint8Array(analyser.fftSize);
            audio.setFFTInfo(analyser.fftSize, audioCtx.sampleRate);
            if (window.analysisManager) window.analysisManager.onAudioInit();
          }
        },
        cameraMode: () => { camState.autoMode = val; },
        cameraDistance: () => { camState.targetDistance = val; },
        cameraSpeed: () => { config.cameraSpeed = val; },
        cameraShake: () => { config.cameraShake = val; },
        particleMode: () => { config.particleMode = val; },
        fieldMode: () => { config.fieldMode = val; },
        symmetry: () => { config.symmetry = val; },
        turbulence: () => { config.turbulence = val; },
        cohesion: () => { config.cohesion = val; },
        bloomStrength: () => { config.bloomStrength = val; },
        bloomRadius: () => { config.bloomRadius = val; },
        glitchAmount: () => { config.glitchAmount = val; },
        vignette: () => { config.vignette = val; },
        grain: () => { config.grain = val; },
        aberration: () => { config.aberration = val; },
        anamorphic: () => { config.anamorphic = val; },
        scanlines: () => { config.scanlines = val; },
        filmLook: () => { config.filmLook = val; },
        bgPatternStrength: () => { config.bgPatternStrength = val; },
        spectrogramMode: () => { config.spectrogramMode = val; },
        spectrogramColor: () => { config.spectrogramColor = val; },
        sensKick: () => { config.sensKick = val; },
        sensSnare: () => { config.sensSnare = val; },
        sensHihat: () => { config.sensHihat = val; },
        waveZoom: () => { config.waveZoom = val; },
        gradeLift: () => { if (screenFXPass.uniforms.uLift) screenFXPass.uniforms.uLift.value.set(config.gradeLift); },
        gradeGamma: () => { if (screenFXPass.uniforms.uGamma) screenFXPass.uniforms.uGamma.value.set(config.gradeGamma); },
        gradeGain: () => { if (screenFXPass.uniforms.uGain) screenFXPass.uniforms.uGain.value.set(config.gradeGain); },
        gradeSat: () => { if (screenFXPass.uniforms.uGradeSat) screenFXPass.uniforms.uGradeSat.value = config.gradeSat; },
        gradeVibrance: () => { if (screenFXPass.uniforms.uGradeVibrance) screenFXPass.uniforms.uGradeVibrance.value = config.gradeVibrance; },
        // RGB Curves
        curveRShadows: () => { updateCurveTexture('R'); },
        curveRMids: () => { updateCurveTexture('R'); },
        curveRHighlights: () => { updateCurveTexture('R'); },
        curveRWhites: () => { updateCurveTexture('R'); },
        curveGShadows: () => { updateCurveTexture('G'); },
        curveGMids: () => { updateCurveTexture('G'); },
        curveGHighlights: () => { updateCurveTexture('G'); },
        curveGWhites: () => { updateCurveTexture('G'); },
        curveBShadows: () => { updateCurveTexture('B'); },
        curveBMids: () => { updateCurveTexture('B'); },
        curveBHighlights: () => { updateCurveTexture('B'); },
        curveBWhites: () => { updateCurveTexture('B'); },
        // Split Toning
        splitToneShadows: () => { if (screenFXPass.uniforms.uSplitToneShadows) screenFXPass.uniforms.uSplitToneShadows.value.set(config.splitToneShadows); },
        splitToneHighlights: () => { if (screenFXPass.uniforms.uSplitToneHighlights) screenFXPass.uniforms.uSplitToneHighlights.value.set(config.splitToneHighlights); },
        splitToneBalance: () => { if (screenFXPass.uniforms.uSplitToneBalance) screenFXPass.uniforms.uSplitToneBalance.value = config.splitToneBalance; },
        // Color Temperature
        colorTemp: () => { if (screenFXPass.uniforms.uColorTemp) screenFXPass.uniforms.uColorTemp.value = config.colorTemp; },
        tint: () => { if (screenFXPass.uniforms.uTint) screenFXPass.uniforms.uTint.value = config.tint; },
        // Film Response
        filmCurve: () => { if (screenFXPass.uniforms.uFilmCurve) screenFXPass.uniforms.uFilmCurve.value = parseFloat(config.filmCurve); },
        // Channel Mixer
        channelMixerRR: () => { updateChannelMixer(); },
        channelMixerRG: () => { updateChannelMixer(); },
        channelMixerRB: () => { updateChannelMixer(); },
        channelMixerGR: () => { updateChannelMixer(); },
        channelMixerGG: () => { updateChannelMixer(); },
        channelMixerGB: () => { updateChannelMixer(); },
        channelMixerBR: () => { updateChannelMixer(); },
        channelMixerBG: () => { updateChannelMixer(); },
        channelMixerBB: () => { updateChannelMixer(); },
        godRaysInt: () => { config.godRaysInt = val; },
        hueRotate: () => { screenFXPass.uniforms.uHueRotate.value = val / 360; },
        lightKeyInt: () => { config.lightKeyInt = val; },
        lightFillInt: () => { config.lightFillInt = val; },
        lightRimInt: () => { config.lightRimInt = val; },
        matMetal: () => { if (wireframeMesh && wireframeMesh.material.metalness !== undefined) wireframeMesh.material.metalness = val; },
        matRough: () => { if (wireframeMesh && wireframeMesh.material.roughness !== undefined) wireframeMesh.material.roughness = val; },
        lutInt: () => { screenFXPass.uniforms.uLutIntensity.value = val; },
        showInner: () => { if (innerMesh) innerMesh.visible = config.showInner; },
        showOuter: () => { if (outerMesh) outerMesh.visible = config.showOuter; },
        showWaveform: () => { if (waveformRing) waveformRing.visible = config.showWaveform; },
        showBars: () => { freqBars.forEach(b => b.visible = config.showBars); },
        showConnections: () => { if (connectionLines) connectionLines.visible = config.showConnections; },
        showParticles: () => { if (particleSystem) particleSystem.visible = config.showParticles; },
        showShockwaves: () => { shockwaves.forEach(s => s.mesh.visible = config.showShockwaves); },
        showLightRays: () => buildLightRays(),
        showAurora: () => buildAurora(),
        showEnergyField: () => buildEnergyField(),
        showOrbitals: () => buildOrbitals(),
        negativeSpace: () => { if (rimMesh) rimMesh.visible = config.negativeSpace; wireframeMesh.material.blending = config.negativeSpace ? THREE.NormalBlending : THREE.AdditiveBlending; },
        showHDRI: () => { scene.environment = config.showHDRI ? hdriMap : null; buildMainGeometry(); },
        goboMode: () => { config.goboMode = val; },
        dofEnabled: () => { config.dofEnabled = val; },
        dofFocusDistance: () => { config.dofFocusDistance = val; },
        dofAperture: () => { config.dofAperture = val; },
        dofBokehScale: () => { config.dofBokehScale = val; },
        dofAutoFocus: () => { config.dofAutoFocus = val; },
        cameraTransitionType: () => { config.cameraTransitionType = val; },
        cameraTransitionDuration: () => { config.cameraTransitionDuration = val; },
        shakeProfile: () => { config.shakeProfile = val; },
        shakeDirectionBias: () => { config.shakeDirectionBias = val; },
        shakeFrequency: () => { config.shakeFrequency = val; },
        shakeDecay: () => { config.shakeDecay = val; },
        camPathLoop: () => { config.camPathLoop = val; },
        dynamicParticlesEnabled: () => { config.dynamicParticlesEnabled = val; },
        dynParticleEmitter: () => { config.dynParticleEmitter = val; },
        dynParticleVelocity: () => { config.dynParticleVelocity = val; },
        dynParticleShape: () => { config.dynParticleShape = val; },
        dynParticleCount: () => { config.dynParticleCount = val; },
        dynParticleSpawnRate: () => { config.dynParticleSpawnRate = val; },
        dynParticleLifespan: () => { config.dynParticleLifespan = val; },
        dynParticleSize: () => { config.dynParticleSize = val; },
        dynForceGravity: () => { config.dynForceGravity = val; },
        dynForceVortex: () => { config.dynForceVortex = val; },
        dynForceTurbulence: () => { config.dynForceTurbulence = val; },
        dynAttractorStrength: () => { config.dynAttractorStrength = val; },
        dynCollisionEnabled: () => { config.dynCollisionEnabled = val; },
        dynAudioReactiveSpawn: () => { config.dynAudioReactiveSpawn = val; },
        dynAudioVelocityMult: () => { config.dynAudioVelocityMult = val; },
        dynParticleTrailLength: () => { config.dynParticleTrailLength = val; },
        screenshotRes: () => { config.screenshotRes = val; },
        overlayText: () => { config.overlayText = val; updateStreamOverlay(); },
        webcamPosition: () => { config.webcamPosition = val; updateWebcamPosition(); },
        recQuality: () => { config.recQuality = val; },
        showStreamOverlay: () => { updateStreamOverlay(); },
        showBpmOverlay: () => { updateStreamOverlay(); },
        showWebcam: () => { toggleWebcam(config.showWebcam); },
        webcamChromaKey: () => { updateStreamOverlay(); }
      };

      if (callbacks[key]) callbacks[key]();
    }

    // Final Listeners and Initialization
    document.addEventListener('DOMContentLoaded', () => {
      // Setup Toggles (using event delegation for simplicity or individual listeners)
      document.querySelectorAll('.toggle').forEach(toggle => {
        toggle.addEventListener('click', () => {
          toggle.classList.toggle('active');
          handleBinding({ target: toggle });
        });
      });

      // Setup Data-Bound Elements (select, input)
      document.querySelectorAll('[data-bind]').forEach(el => {
        if (el.classList.contains('toggle')) return; // Handled above
        const eventType = (el.type === 'range' || el.type === 'color' || el.type === 'text') ? 'input' : 'change';
        el.addEventListener(eventType, handleBinding);
      });

      // UI Tab Functionality (Already existing, but ensure listeners are active)
      document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', () => {
          document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.settings-panel').forEach(p => p.classList.remove('active'));
          tab.classList.add('active');
          const panelId = tab.dataset.tab;
          document.querySelector(`.settings-panel[data-panel="${panelId}"]`)?.classList.add('active');
        });
      });

      // Control Buttons
      const playIcon = document.getElementById('playIcon');
      const pauseIcon = document.getElementById('pauseIcon');
      const togglePlay = () => {
        if (!audioEl.src) return;
        initAudio();
        if (audioCtx.state === 'suspended') audioCtx.resume();
        if (audioEl.paused) {
          audioEl.play(); playing = true;
          if (playIcon) playIcon.style.display = 'none';
          if (pauseIcon) pauseIcon.style.display = 'block';
          if (statusEl) statusEl.classList.add('playing');
        } else {
          audioEl.pause(); playing = false;
          if (playIcon) playIcon.style.display = 'block';
          if (pauseIcon) pauseIcon.style.display = 'none';
        }
      };

      document.getElementById('playBtn')?.addEventListener('click', togglePlay);
      audioEl.addEventListener('ended', () => {
        playing = false;
        if (playIcon) playIcon.style.display = 'block';
        if (pauseIcon) pauseIcon.style.display = 'none';
      });

      // Recording
      let mediaRecorder, recordedChunks = [];
      document.getElementById('recordBtn')?.addEventListener('click', () => {
        if (mediaRecorder && mediaRecorder.state === 'recording') {
          mediaRecorder.stop();
          document.getElementById('rec-indicator')?.classList.remove('active');
          return;
        }
        if (!mediaDest) initAudio();
        const canvasStream = renderer.domElement.captureStream(60);
        const audioStream = mediaDest.stream;
        const combined = new MediaStream([...canvasStream.getTracks(), ...audioStream.getTracks()]);
        const bpsMap = { low: 2500000, medium: 6000000, high: 12000000 };
        const bps = bpsMap[config.recQuality] || 8000000;

        try {
          mediaRecorder = new MediaRecorder(combined, { mimeType: 'video/webm; codecs=vp9', videoBitsPerSecond: bps });
          recordedChunks = [];
          mediaRecorder.ondataavailable = e => { if (e.data.size > 0) recordedChunks.push(e.data); };
          mediaRecorder.onstop = () => {
            const blob = new Blob(recordedChunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = 'EchoVerse_Render.webm'; a.click();
          };
          mediaRecorder.start();
          document.getElementById('rec-indicator')?.classList.add('active');
        } catch (err) {
          console.error("Recording failed", err);
          showStatus("Recording not supported in this browser");
        }
      });

      // Utility Listeners
      document.getElementById('file')?.addEventListener('change', e => {
        const file = e.target.files[0];
        if (file) { initAudio(); audioEl.src = URL.createObjectURL(file); audioEl.load(); }
      });
      document.getElementById('randomBtn')?.addEventListener('click', randomize);
      document.getElementById('fullscreenBtn')?.addEventListener('click', () => {
        if (!document.fullscreenElement) document.documentElement.requestFullscreen(); else document.exitFullscreen();
      });
      document.getElementById('takeSnapshot')?.addEventListener('click', takeHighResSnapshot);
      document.getElementById('exportPreset')?.addEventListener('click', exportConfig);
      document.getElementById('importPreset')?.addEventListener('click', importConfig);

      // Camera Presets & Path
      let selectedCamSlot = 0;
      document.querySelectorAll('.cam-preset-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          selectedCamSlot = parseInt(btn.dataset.slot) - 1;
          document.querySelectorAll('.cam-preset-btn').forEach(b => b.classList.remove('selected'));
          btn.classList.add('selected');
          loadCameraPreset(selectedCamSlot);
        });
      });
      document.getElementById('saveCamPreset')?.addEventListener('click', () => saveCameraPreset(selectedCamSlot));
      document.getElementById('clearCamPreset')?.addEventListener('click', () => clearCameraPreset(selectedCamSlot));
      document.getElementById('camPathRecord')?.addEventListener('click', () => { if (cameraPath.recording) stopRecording(); else startRecording(); });
      document.getElementById('camPathPlay')?.addEventListener('click', () => { if (cameraPath.playing) stopPlayback(); else startPlayback(); });
      document.getElementById('camPathStop')?.addEventListener('click', () => { stopRecording(); stopPlayback(); });

      document.getElementById('toggleZenMode')?.addEventListener('click', (e) => {
        config.zenMode = e.target.classList.contains('active');
        document.body.classList.toggle('zen-active', config.zenMode);
      });

      // UI Management logic
      const ui = document.getElementById('ui');
      let uiTimeout;
      const resetUiTimer = () => {
        ui.classList.remove('autohide');
        clearTimeout(uiTimeout);
        if (!config.zenMode) {
          uiTimeout = setTimeout(() => {
            if (!ui.matches(':hover')) ui.classList.add('autohide');
          }, 3000);
        }
      };
      window.addEventListener('mousemove', resetUiTimer);
      window.addEventListener('mousedown', resetUiTimer);

      // Tooltip Updates
      const updateTooltips = () => {
        document.querySelectorAll('[data-bind], .btn').forEach(el => {
          const val = el.value || '';
          const name = el.id || el.dataset.bind || '';
          if (name) el.setAttribute('data-tooltip', `${name.charAt(0).toUpperCase() + name.slice(1)} ${val} `);
        });
      };
      document.addEventListener('input', updateTooltips);
      updateTooltips();

      // Keyboard Shortcut Badges
      const shortcuts = { 'playBtn': 'SPACE', 'randomBtn': 'R', 'fullscreenBtn': 'F' };
      Object.keys(shortcuts).forEach(id => {
        const btn = document.getElementById(id);
        if (btn) btn.setAttribute('data-shortcut', shortcuts[id]);
      });

      // Drag and Drop
      const body = document.body;
      body.addEventListener('dragover', (e) => {
        e.preventDefault();
        body.classList.add('drop-zone-active');
      });
      body.addEventListener('dragleave', () => body.classList.remove('drop-zone-active'));
      body.addEventListener('drop', (e) => {
        e.preventDefault();
        body.classList.remove('drop-zone-active');
        const file = e.dataTransfer.files[0];
        if (file && file.type.startsWith('audio/')) {
          initAudio(); audioEl.src = URL.createObjectURL(file); audioEl.load();
        }
      });

      // Extra UI setup
      updateStreamOverlay();
      updateWebcamPosition();
      updateResponsiveElements();
      updateCamPresetUI();
    });

    // Global Event Listeners (Keyboard, Resize)
    document.addEventListener('keydown', e => {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') return;
      switch (e.key.toLowerCase()) {
        case ' ': e.preventDefault(); document.getElementById('playBtn')?.click(); break;
        case 'u':
          document.getElementById('ui')?.classList.toggle('hidden');
          document.getElementById('status')?.classList.toggle('hidden');
          document.getElementById('spectrum-overlay')?.classList.toggle('hidden');
          break;
        case 'r': randomize(); break;
        case 'f': document.getElementById('fullscreenBtn')?.click(); break;
        case 'p': openPresetModal(); break;
        default:
          if (!isNaN(e.key) && e.key >= 1 && e.key <= 8) {
            const tabs = document.querySelectorAll('.tab');
            tabs[parseInt(e.key) - 1]?.click();
          }
      }
    });

    window.addEventListener('resize', () => {
      const w = window.innerWidth, h = window.innerHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      if (renderer) renderer.setSize(w, h);
      if (composer) composer.setSize(w, h);
      if (bloomPass) bloomPass.resolution.set(w, h);
      if (bgUniforms) bgUniforms.uResolution.value.set(w, h);
      if (screenFXPass) screenFXPass.uniforms.uResolution.value.set(w, h);
      if (specCanvas) specCanvas.width = w;
      updateResponsiveElements();
    });

    function updateResponsiveElements() {
      const w = window.innerWidth;
      const ui = document.getElementById('ui');
      if (!ui) return;
      if (w < 768) { ui.style.padding = '8px'; ui.style.gap = '8px'; }
      else if (w < 1200) { ui.style.padding = '15px'; ui.style.gap = '12px'; }
      else { ui.style.padding = '25px'; ui.style.gap = '20px'; }
    }

    // Dynamic Overlay Update Loop
    setInterval(() => {
      if (config.showStreamOverlay && config.showBpmOverlay) {
        const bpmEl = document.getElementById('overlay-bpm');
        const nrgEl = document.getElementById('overlay-energy');
        if (bpmEl) bpmEl.textContent = `${Math.round(audio.bpmSmooth || 0)} BPM`;
        if (nrgEl) nrgEl.textContent = `ENERGY: ${((audio.energy || 0) * 100).toFixed(0)}%`;
      }
    }, 100);
  </script>
</body>

</html>